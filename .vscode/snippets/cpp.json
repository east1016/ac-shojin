{
	// template
	"init": {
		"prefix": "init",
		"body": [
			"#pragma GCC target(\"avx2\")",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"unroll-loops\")",
			"#include <bits/stdc++.h>",
			"",
			"#include <atcoder/all>",
			"#define rep(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)",
			"using namespace atcoder;",
			"using namespace std;",
			"",
			"typedef long long ll;",
			"",
			"void solve() {}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout << fixed << setprecision(15);",
			"    solve();",
			"}",
			"",
		],
		"description": ""
	},
	"codeforces": {
		"prefix": "codeforces",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#include <atcoder/all>",
			"#define rep(i, a, b) for (ll i = (ll)(a); i < (ll)(b); i++)",
			"using namespace atcoder;",
			"using namespace std;",
			"",
			"typedef long long ll;",
			"",
			"void solve() {}",
			"",
			"int main() {",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(nullptr);",
			"    cout << fixed << setprecision(15);",
			"    solve();",
			"}",
			"",
		],
		"description": ""
	},
	// struct
	"Tree": {
		"prefix": "Tree",
		"body": [
			"template <typename T = int>",
			"struct Tree {",
			"    // https://atcoder.jp/contests/abc438/submissions/72041072",
			"    int n, root;",
			"    bool edge_cost, lca_ok, hld_ok;",
			"    vector<vector<int>> tr, chi, par_exp;",
			"    vector<vector<pair<int, T>>> tr_edge_cost;",
			"    vector<int> par, dep, subsize;",
			"",
			"    /* HL分解用 */",
			"    vector<vector<int>> gr_hld;",
			"    vector<int> stsize, pathtop, in, out, in_order;",
			"",
			"    Tree() : edge_cost(false), lca_ok(false), hld_ok(false) {}",
			"",
			"    Tree(int n) : n(n), edge_cost(false), lca_ok(false), hld_ok(false) {}",
			"",
			"    /**",
			"     * @brief 頂点 s と t をつなぐ",
			"     */",
			"    void connect(int s, int t) {",
			"        if (tr.size() < n) tr.resize(n);",
			"        tr[s].push_back(t);",
			"        tr[t].push_back(s);",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 s と t をコスト c でつなぐ",
			"     */",
			"    void connect(int s, int t, T c) {",
			"        connect(s, t);",
			"        if (tr_edge_cost.size() < n) tr_edge_cost.resize(n);",
			"        tr_edge_cost[s].push_back({t, c});",
			"        tr_edge_cost[t].push_back({s, c});",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 d を根として par, dep, chi, subsize を求める",
			"     */",
			"    void make(int _root) {",
			"        root = _root;",
			"        chi = vector<vector<int>>(n);",
			"        par = vector<int>(n);",
			"        dep = vector<int>(n);",
			"        subsize = vector<int>(n);",
			"        auto dfs = [&](auto dfs, int d, int p) -> void {",
			"            par[d] = p;",
			"            dep[d] = (p == -1 ? 0 : dep[p] + 1);",
			"            int cur_subsize = 1;",
			"            for (int &v : tr[d]) {",
			"                if (v == p) continue;",
			"                dfs(dfs, v, d);",
			"                cur_subsize += subsize[v];",
			"                chi[d].push_back(v);",
			"            }",
			"            subsize[d] = cur_subsize;",
			"        };",
			"        dfs(dfs, _root, -1);",
			"    }",
			"",
			"    /**",
			"     * @brief LCA 前処理",
			"     */",
			"    void init_lca() {",
			"        int ct = 0;",
			"        while (n >= (1 << ct)) ct++;",
			"        ct++;",
			"        par_exp = vector<vector<int>>(ct, vector<int>(n, -1));",
			"        rep(i, 0, n) par_exp[0][i] = par[i];",
			"        rep(i, 0, ct - 1) {",
			"            rep(j, 0, n) {",
			"                if (par_exp[i][j] == -1)",
			"                    par_exp[i + 1][j] = -1;",
			"                else",
			"                    par_exp[i + 1][j] = par_exp[i][par_exp[i][j]];",
			"            }",
			"        }",
			"        lca_ok = true;",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 u と v の LCA を求める",
			"     */",
			"    int lca(int u, int v) {",
			"        if (!lca_ok) init_lca();",
			"        int h = par_exp.size();",
			"        if (dep[u] > dep[v]) swap(u, v);",
			"        for (int i = h - 1; i >= 0; i--) {",
			"            if (((dep[v] - dep[u]) >> i) & 1) v = par_exp[i][v];",
			"        }",
			"        if (u == v) return u;",
			"        for (int i = h - 1; i >= 0; i--) {",
			"            if (par_exp[i][u] != par_exp[i][v]) {",
			"                u = par_exp[i][u];",
			"                v = par_exp[i][v];",
			"            }",
			"        }",
			"        return par_exp[0][u];",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 v から k 回上に行った頂点を求める",
			"     */",
			"    int up(int v, int k) {",
			"        if (!lca_ok) init_lca();",
			"        if (dep[v] < k) return -1;",
			"        int h = par_exp.size();",
			"        for (int i = h - 1; i >= 0; i--) {",
			"            if ((k >> i) & 1) v = par_exp[i][v];",
			"        }",
			"        return v;",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 s と t の中間の頂点を求める",
			"     */",
			"    vector<int> mid_point(int s, int t) {",
			"        if (!lca_ok) init_lca();",
			"        if (dep[s] < dep[t]) swap(s, t);",
			"        int p = lca(s, t);",
			"        int dis = abs(dep[s] - dep[p]) + abs(dep[t] - dep[p]);",
			"        int ue = dis / 2;",
			"        if (dis % 2 == 0) return {up(s, ue)};",
			"        return {up(s, ue), up(s, ue + 1)};",
			"        // if (dis % 2 == 0) return up(s, ue);",
			"        // return -1;",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 s と t の距離を求める",
			"     */",
			"    int dist(int s, int t) {",
			"        if (!lca_ok) init_lca();",
			"        return dep[s] + dep[t] - 2 * dep[lca(s, t)];",
			"    }",
			"",
			"    /**",
			"     * @brief HL 分解の前処理",
			"     */",
			"    void init_hld() {",
			"        hld_ok = true;",
			"        gr_hld = tr;",
			"        stsize.assign(n, 0);",
			"        par.assign(n, -1);",
			"        pathtop.assign(n, 0);",
			"        in.assign(n, 0);",
			"        out.assign(n, 0);",
			"        if (!par_exp.size()) init_lca();",
			"        int tm = 0;",
			"        std::function<void(int, int)> dfs_size = [&](int u, int p) {",
			"            stsize[u] = 1;",
			"            par[u] = p;",
			"            for (int &v : gr_hld[u]) {",
			"                if (v == p) {",
			"                    if (v == gr_hld[u].back())",
			"                        break;",
			"                    else",
			"                        swap(v, gr_hld[u].back());",
			"                }",
			"                dfs_size(v, u);",
			"                stsize[u] += stsize[v];",
			"                if (stsize[v] > stsize[gr_hld[u][0]]) swap(v, gr_hld[u][0]);",
			"            }",
			"        };",
			"        std::function<void(int, int)> dfs_path = [&](int u, int p) {",
			"            in[u] = tm++;",
			"            for (int v : gr_hld[u]) {",
			"                if (v == p) continue;",
			"                pathtop[v] = (v == gr_hld[u][0] ? pathtop[u] : v);",
			"                dfs_path(v, u);",
			"            }",
			"            out[u] = tm;",
			"        };",
			"        dfs_size(root, -1);",
			"        pathtop[root] = root;",
			"        dfs_path(root, -1);",
			"        in_order.resize(n);",
			"        for (int i = 0; i < n; i++) in_order[in[i]] = i;",
			"    }",
			"",
			"    /**",
			"     * @brief パスクエリに対応する区間を求める",
			"     */",
			"    vector<pair<int, int>> path_query(int a, int b, bool edgeQuery = false) {",
			"        int pta = pathtop[a], ptb = pathtop[b];",
			"        vector<pair<int, int>> ret;",
			"        while (pathtop[a] != pathtop[b]) {",
			"            if (in[pta] > in[ptb]) {",
			"                ret.push_back({in[pta], in[a] + 1});",
			"                a = par[pta], pta = pathtop[a];",
			"            } else {",
			"                ret.push_back({in[ptb], in[b] + 1});",
			"                b = par[ptb], ptb = pathtop[b];",
			"            }",
			"        }",
			"        if (in[a] > in[b]) swap(a, b);",
			"        ret.push_back({in[a], in[b] + 1});",
			"        if (edgeQuery) {",
			"            int c = lca(a, b);",
			"            for (auto &p : ret) {",
			"                if (p.first == in[c]) p.first++;",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"",
			"    /**",
			"     * @brief 部分木クエリに対応する区間を求める",
			"     */",
			"    pair<int, int> subtree_query(int d, bool edgeQuery = false) {",
			"        return {in[d] + edgeQuery, out[d]};",
			"    }",
			"",
			"    /**",
			"     * @brief 頂点 d の HL 分解における番号を返す",
			"     */",
			"    int to_hld(int d) { return in[d]; }",
			"",
			"    /**",
			"     * @brief HL 分解における番号 d の元の頂点を返す",
			"     */",
			"    int from_hld(int d) { return in_order[d]; }",
			"",
			"    /**",
			"     * @brief dfsのtemplate",
			"     */",
			"    void dfs(int root, int par = -1) {",
			"        if (edge_cost) {",
			"            for (auto &[p, c] : tr_edge_cost[root]) {",
			"                if (p == par) continue;",
			"                dfs(p, root);",
			"            }",
			"            return;",
			"        }",
			"        for (auto &p : tr[root]) {",
			"            if (p == par) continue;",
			"            dfs(p, root);",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"Graph": {
		"prefix": "Graph",
		"body": [
			"template <typename T>",
			"struct Graph {",
			"    struct edge {",
			"        int to;",
			"        T cost;",
			"    };",
			"",
			"    int n;",
			"    vector<vector<edge>> gr;",
			"    vector<T> dist;",
			"    vector<int> prever;",
			"",
			"    Graph(int n) : n(n) { init(); }",
			"    T inf() { return numeric_limits<T>::max(); }",
			"    T zero() { return T(); }",
			"",
			"    void init() {",
			"        gr.resize(n);",
			"        dist.resize(n, inf());",
			"    }",
			"    void add_edge(int s, int t, T cost) { gr[s].emplace_back(edge{t, cost}); }",
			"    void dijkstra(int s) {",
			"        dist = vector<T>(n, inf());",
			"        prever = vector<int>(n, -1);",
			"        dist[s] = zero();",
			"        priority_queue<pair<T, int>, vector<pair<T, int>>,",
			"                       greater<pair<T, int>>>",
			"            q;",
			"        q.push({zero(), s});",
			"        while (!q.empty()) {",
			"            int now;",
			"            T nowdist;",
			"            tie(nowdist, now) = q.top();",
			"            q.pop();",
			"            if (dist[now] < nowdist) continue;",
			"            for (auto e : gr[now]) {",
			"                T nextdist = nowdist + e.cost;",
			"                if (dist[e.to] > nextdist) {",
			"                    prever[e.to] = now;",
			"                    dist[e.to] = nextdist;",
			"                    q.push({dist[e.to], e.to});",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    void bfs01(int s) {",
			"        dist = vector<T>(n, inf());",
			"        prever = vector<int>(n, -1);",
			"        dist[s] = zero();",
			"        deque<int> q;",
			"        q.push_back(s);",
			"        while (!q.empty()) {",
			"            int now = q.front();",
			"            q.pop_front();",
			"            for (auto e : gr[now]) {",
			"                T nextdist = dist[now] + e.cost;",
			"                if (dist[e.to] > nextdist) {",
			"                    prever[e.to] = now;",
			"                    dist[e.to] = nextdist;",
			"                    if (e.cost == 0)",
			"                        q.push_front(e.to);",
			"                    else",
			"                        q.push_back(e.to);",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<int> get_path(int t) {",
			"        if (dist[t] >= inf()) return {-1};",
			"        vector<int> path;",
			"        for (; t != -1; t = prever[t]) {",
			"            path.push_back(t);",
			"        }",
			"        reverse(path.begin(), path.end());",
			"        return path;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"Namori": {
		"prefix": "Namori",
		"body": [
			"struct Namori {",
			"    /**",
			"     * Namori Graph",
			"     * https://atcoder.jp/contests/nupc2024/submissions/64262284",
			"     */",
			"    int n, m, cycle_len;",
			"    vector<vector<int>> gr;",
			"    vector<int> cycle, root, depth, cycle_order, par;",
			"",
			"    Namori(int n = 0) : n(n) {",
			"        m = 0;",
			"        gr.resize(n);",
			"        root.resize(n);",
			"        depth.resize(n);",
			"        par.resize(n);",
			"        cycle_order.resize(n, -1);",
			"    }",
			"",
			"    void connect(int s, int t) {",
			"        m++;",
			"        gr[s].push_back(t);",
			"        gr[t].push_back(s);",
			"        if (m == n) make();",
			"    }",
			"",
			"    void make() {",
			"        if (cycle.size()) return;",
			"        assert(n == m);",
			"        vector<bool> is_cycle(n, true);",
			"        vector<int> deg(n);",
			"        for (int i = 0; i < n; i++) {",
			"            for (auto j : gr[i]) {",
			"                if (i > j) continue;",
			"                deg[i]++;",
			"                deg[j]++;",
			"            }",
			"        }",
			"        queue<int> que;",
			"        for (int i = 0; i < n; i++) {",
			"            if (deg[i] == 1) {",
			"                que.push(i);",
			"            }",
			"        }",
			"        while (!que.empty()) {",
			"            int v = que.front();",
			"            que.pop();",
			"            is_cycle[v] = false;",
			"            for (auto to : gr[v]) {",
			"                if (deg[to] >= 2) {",
			"                    deg[to]--;",
			"                    if (deg[to] == 1) {",
			"                        que.push(to);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        auto make_depth = [&](auto make_depth, int v, int p, int d) -> void {",
			"            depth[v] = d;",
			"            par[v] = p;",
			"            for (auto to : gr[v]) {",
			"                if (to != p && !is_cycle[to]) {",
			"                    make_depth(make_depth, to, v, d + 1);",
			"                }",
			"            }",
			"        };",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            if (is_cycle[i]) {",
			"                make_depth(make_depth, i, -1, 0);",
			"            }",
			"        }",
			"",
			"        auto dfs = [&](auto dfs, int v, int p) -> void {",
			"            root[v] = root[p];",
			"            for (auto to : gr[v]) {",
			"                if (to != p) dfs(dfs, to, v);",
			"            }",
			"        };",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            if (is_cycle[i]) {",
			"                root[i] = i;",
			"                for (auto to : gr[i]) {",
			"                    if (!is_cycle[to]) {",
			"                        dfs(dfs, to, i);",
			"                    }",
			"                }",
			"            }",
			"        }",
			"",
			"        for (int i = 0; i < n; i++) {",
			"            if (is_cycle[i]) {",
			"                int d = i;",
			"                while (1) {",
			"                    cycle.push_back(d);",
			"                    is_cycle[d] = false;",
			"                    int next_d = -1;",
			"                    for (auto p : gr[d]) {",
			"                        if (is_cycle[p]) {",
			"                            next_d = p;",
			"                            break;",
			"                        }",
			"                    }",
			"                    if (next_d != -1) {",
			"                        d = next_d;",
			"                        continue;",
			"                    }",
			"                    break;",
			"                }",
			"                break;",
			"            }",
			"        }",
			"",
			"        for (int i = 0; i < cycle.size(); i++) {",
			"            cycle_order[cycle[i]] = i;",
			"        }",
			"        cycle_len = cycle.size();",
			"    }",
			"",
			"    vector<vector<int>> lca_par;",
			"    void make_lca() {",
			"        if (lca_par.size()) return;",
			"        int m = 1;",
			"        while ((1 << m) <= n) m++;",
			"        lca_par.resize(m, vector<int>(n, -1));",
			"        for (int i = 0; i < n; i++) {",
			"            lca_par[0][i] = par[i];",
			"        }",
			"        for (int i = 1; i < m; i++) {",
			"            for (int j = 0; j < n; j++) {",
			"                if (lca_par[i - 1][j] != -1) {",
			"                    lca_par[i][j] = lca_par[i - 1][lca_par[i - 1][j]];",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    int lca(int u, int v) {",
			"        if (root[u] != root[v]) {",
			"            return -1;",
			"        }",
			"        make_lca();",
			"        if (depth[u] < depth[v]) swap(u, v);",
			"        int m = lca_par.size();",
			"        for (int i = m - 1; i >= 0; i--) {",
			"            if (lca_par[i][u] != -1 && depth[lca_par[i][u]] >= depth[v]) {",
			"                u = lca_par[i][u];",
			"            }",
			"        }",
			"        if (u == v) return u;",
			"        for (int i = m - 1; i >= 0; i--) {",
			"            if (lca_par[i][u] != lca_par[i][v]) {",
			"                u = lca_par[i][u];",
			"                v = lca_par[i][v];",
			"            }",
			"        }",
			"        return par[u];",
			"    }",
			"",
			"    int dist(int u, int v) {",
			"        if (root[u] != root[v]) {",
			"            int delta = abs(cycle_order[root[u]] - cycle_order[root[v]]);",
			"            int ret = depth[u] + depth[v];",
			"            ret += min(delta, cycle_len - delta);",
			"            return ret;",
			"        }",
			"        int l = lca(u, v);",
			"        return depth[u] + depth[v] - depth[l] * 2;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"CC": {
		"prefix": "CC",
		"body": [
			"template <typename T = long long>",
			"struct CC {",
			"    bool initialized;",
			"    vector<T> xs;",
			"    CC() : initialized(false) {}",
			"    void add(T x) { xs.push_back(x); }",
			"    void init() {",
			"        sort(xs.begin(), xs.end());",
			"        xs.erase(unique(xs.begin(), xs.end()), xs.end());",
			"        initialized = true;",
			"    }",
			"    int operator()(T x) {",
			"        if (!initialized) init();",
			"        return upper_bound(xs.begin(), xs.end(), x) - xs.begin() - 1;",
			"    }",
			"    T operator[](int i) {",
			"        if (!initialized) init();",
			"        return xs[i];",
			"    }",
			"    int size() {",
			"        if (!initialized) init();",
			"        return xs.size();",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"Comb": {
		"prefix": "Comb",
		"body": [
			"struct Comb {",
			"    vector<mint> fact, ifact;",
			"    int MAX_COM;",
			"    Comb() {}",
			"    Comb(int n, int mod) {",
			"        MAX_COM = n;",
			"        init(mod, MAX_COM);",
			"    }",
			"    void init(long long MOD, long long MAX_COM) {",
			"        int n = MAX_COM;",
			"        assert(n < MOD);",
			"        fact = vector<mint>(n + 1);",
			"        ifact = vector<mint>(n + 1);",
			"        fact[0] = 1;",
			"        for (int i = 1; i <= n; ++i) fact[i] = fact[i - 1] * i;",
			"        ifact[n] = fact[n].inv();",
			"        for (int i = n; i >= 1; --i) ifact[i - 1] = ifact[i] * i;",
			"    }",
			"    mint operator()(long long n, long long k) {",
			"        if (k < 0 || k > n) return 0;",
			"        return fact[n] * ifact[k] * ifact[n - k];",
			"    }",
			"};",
			"Comb comb(5000010, 998244353);",
			"",
		],
		"description": ""
	},
	"SmallComb": {
		"prefix": "SmallComb",
		"body": [
			"struct SmallComb {",
			"    /**",
			"     * nCk % p",
			"     * 初期化: O(p^2)",
			"     * comb(n, k): O(log n)",
			"     * https://atcoder.jp/contests/arc117/submissions/27619533",
			"     */",
			"    vector<vector<long long>> com;",
			"    long long p;",
			"    SmallComb() {}",
			"    SmallComb(long long _p) : p(_p) { init(p); }",
			"    void init(long long p) {",
			"        com.assign(p, vector<long long>(p));",
			"        com[0][0] = 1;",
			"        for (int i = 1; i < p; i++) {",
			"            com[i][0] = 1;",
			"            for (int j = i; j > 0; j--) {",
			"                com[i][j] = (com[i - 1][j - 1] + com[i - 1][j]) % p;",
			"            }",
			"        }",
			"    }",
			"    long long operator()(long long n, long long k) {",
			"        if (k < 0 || k > n) return 0;",
			"        long long ret = 1;",
			"        while (n > 0) {",
			"            int ni = n % p;",
			"            int ki = k % p;",
			"            ret *= com[ni][ki];",
			"            ret %= p;",
			"            n /= p;",
			"            k /= p;",
			"        }",
			"        return ret;",
			"    }",
			"};",
			"SmallComb scomb(3);",
			"",
		],
		"description": ""
	},
	"RangeSet": {
		"prefix": "RangeSet",
		"body": [
			"template <typename T>",
			"struct RangeSet {",
			"    // https://atcoder.jp/contests/typical90/submissions/71744006",
			"    set<pair<T, T>> st;",
			"    T TINF;",
			"",
			"    RangeSet() {",
			"        TINF = numeric_limits<T>::max() / 2;",
			"        st.emplace(TINF, TINF);",
			"        st.emplace(-TINF, -TINF);",
			"    }",
			"    // [l,r] covered?",
			"    bool covered(T l, T r) {",
			"        assert(l <= r);",
			"        auto ite = prev(st.lower_bound({l + 1, l + 1}));",
			"        return ite->first <= l and r <= ite->second;",
			"    }",
			"    bool covered(T x) { return covered(x, x); }",
			"    // [l, r]がカバーされているなら，その区間を返す.",
			"    // されていないなら[-TINF,-TINF]を返す",
			"    pair<T, T> covered_by(T l, T r) {",
			"        assert(l <= r);",
			"        auto ite = prev(st.lower_bound({l + 1, l + 1}));",
			"        if (ite->first <= l and r <= ite->second) return *ite;",
			"        return make_pair(-TINF, -TINF);",
			"    }",
			"    pair<T, T> covered_by(T x) { return covered_by(x, x); }",
			"    // insert[l,r], 増加量を返す",
			"    T insert(T l, T r) {",
			"        assert(l <= r);",
			"        auto ite = prev(st.lower_bound({l + 1, l + 1}));",
			"        if (ite->first <= l and r <= ite->second) return T(0);",
			"        T sum_erased = T(0);",
			"        if (ite->first <= l and l <= ite->second + 1) {",
			"            l = ite->first;",
			"            sum_erased += ite->second - ite->first + 1;",
			"            ite = st.erase(ite);",
			"        } else",
			"            ite = next(ite);",
			"        while (r > ite->second) {",
			"            sum_erased += ite->second - ite->first + 1;",
			"            ite = st.erase(ite);",
			"        }",
			"        if (ite->first - 1 <= r and r <= ite->second) {",
			"            sum_erased += ite->second - ite->first + 1;",
			"            r = ite->second;",
			"            st.erase(ite);",
			"        }",
			"        st.emplace(l, r);",
			"        return r - l + 1 - sum_erased;",
			"    }",
			"    T insert(T x) { return insert(x, x); }",
			"    // erase [l,r], 減少量を返す",
			"    T erase(T l, T r) {",
			"        assert(l <= r);",
			"        auto ite = prev(st.lower_bound({l + 1, l + 1}));",
			"        if (ite->first <= l and r <= ite->second) {",
			"            // 完全に1つの区間に包含されている",
			"            if (ite->first < l) st.emplace(ite->first, l - 1);",
			"            if (r < ite->second) st.emplace(r + 1, ite->second);",
			"            st.erase(ite);",
			"            return r - l + 1;",
			"        }",
			"",
			"        T ret = T(0);",
			"        if (ite->first <= l and l <= ite->second) {",
			"            ret += ite->second - l + 1;  // 消えた",
			"            if (ite->first < l) st.emplace(ite->first, l - 1);",
			"            ite = st.erase(ite);  // 次へ",
			"        } else",
			"            ite = next(ite);",
			"        while (ite->second <= r) {",
			"            ret += ite->second - ite->first + 1;",
			"            ite = st.erase(ite);",
			"        }",
			"        // 右端が区間の間にあるか",
			"        if (ite->first <= r and r <= ite->second) {",
			"            ret += r - ite->first + 1;",
			"            if (r < ite->second) st.emplace(r + 1, ite->second);",
			"            st.erase(ite);",
			"        }",
			"        return ret;",
			"    }",
			"    T erase(T x) { return erase(x, x); }",
			"    // number of range",
			"    int size() { return (int)st.size() - 2; }",
			"    // mex [x,~)",
			"    int mex(T x = 0) {",
			"        auto ite = prev(st.lower_bound({x + 1, x + 1}));",
			"        if (ite->first <= x and x <= ite->second)",
			"            return ite->second + 1;",
			"        else",
			"            return x;",
			"    }",
			"    // mexr (~ , x]",
			"    int mexr(T x = 0) {",
			"        auto ite = prev(st.lower_bound({x + 1, x + 1}));",
			"        if (ite->first <= x and x <= ite->second)",
			"            return ite->first - 1;",
			"        else",
			"            return x;",
			"    }",
			"    // [l,r]との共通要素の個数",
			"    T common_cnt(T l, T r) {",
			"        assert(l <= r);",
			"        T ret = 0;",
			"        for (auto &p : st) {",
			"            if (p.first == -TINF or p.second == TINF) continue;",
			"            if (p.first > r or p.second < l) continue;",
			"            ret += min(r, p.second) - max(l, p.first) + 1;",
			"        }",
			"        return ret;",
			"    }",
			"    void output() {",
			"        cout << \"RangeSet : \";",
			"        for (auto &p : st) {",
			"            if (p.first == -TINF or p.second == TINF) continue;",
			"            cout << \"[\" << p.first << \", \" << p.second << \"] \";",
			"        }",
			"        cout << \"\\n\";",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"RollingHash": {
		"prefix": "RollingHash",
		"body": [
			"struct RollingHash {",
			"    /**",
			"     * ローリングハッシュ",
			"     * https://atcoder.jp/contests/abc141/submissions/72310182",
			"     */",
			"    int n;",
			"    static const ll base1 = 1009;",
			"    static const ll base2 = 2009;",
			"    static const ll mod1 = 1000000007;",
			"    static const ll mod2 = 1000000009;",
			"    vector<ll> hash1, hash2, pow1, pow2;",
			"",
			"    RollingHash() = default;",
			"",
			"    template <typename Seq>",
			"    RollingHash(const Seq &S) {",
			"        init(S);",
			"    }",
			"",
			"    template <typename Seq>",
			"    void init(const Seq &S) {",
			"        n = (int)S.size();",
			"        hash1.assign(n + 1, 0);",
			"        hash2.assign(n + 1, 0);",
			"        pow1.assign(n + 1, 1);",
			"        pow2.assign(n + 1, 1);",
			"        for (int i = 0; i < n; i++) {",
			"            ll x = cv(S[i]);",
			"            hash1[i + 1] = (hash1[i] * base1 + x) % mod1;",
			"            hash2[i + 1] = (hash2[i] * base2 + x) % mod2;",
			"            pow1[i + 1] = (pow1[i] * base1) % mod1;",
			"            pow2[i + 1] = (pow2[i] * base2) % mod2;",
			"        }",
			"    }",
			"",
			"    /**",
			"     * S の [l, r) のハッシュ値を返す",
			"     * O(1)",
			"     */",
			"    inline pair<ll, ll> get(int l, int r) const {",
			"        ll res1 = hash1[r] - hash1[l] * pow1[r - l] % mod1;",
			"        if (res1 < 0) res1 += mod1;",
			"        ll res2 = hash2[r] - hash2[l] * pow2[r - l] % mod2;",
			"        if (res2 < 0) res2 += mod2;",
			"        return make_pair(res1, res2);",
			"    }",
			"",
			"    /**",
			"     * S のハッシュ値を返す",
			"     * O(1)",
			"     */",
			"    inline pair<ll, ll> hash() const { return get(0, (int)hash1.size() - 1); }",
			"",
			"    /**",
			"     * LCP (Longest Common Prefix)",
			"     * O(log N)",
			"     */",
			"    inline int getLCP(int a, int b) const {",
			"        int len = min((int)hash1.size() - a, (int)hash1.size() - b);",
			"        int low = 0, high = len;",
			"        while (high - low > 1) {",
			"            int mid = (low + high) >> 1;",
			"            if (get(a, a + mid) != get(b, b + mid))",
			"                high = mid;",
			"            else",
			"                low = mid;",
			"        }",
			"        return low;",
			"    }",
			"",
			"    /**",
			"     * hash h1 と 長さ h2_len の文字列の hash h2 を結合",
			"     */",
			"    pair<ll, ll> concat(pair<ll, ll> h1, pair<ll, ll> h2, ll h2_len) {",
			"        if (h2_len < (int)pow1.size())",
			"            return make_pair((h1.first * pow1[h2_len] + h2.first) % mod1,",
			"                             (h1.second * pow2[h2_len] + h2.second) % mod2);",
			"        return make_pair(",
			"            (h1.first * pow_mod(base1, h2_len + 1, mod1) + h2.first) % mod1,",
			"            (h1.second * pow_mod(base2, h2_len + 1, mod2) + h2.second) % mod2);",
			"    }",
			"",
			"    /**",
			"     * 文字列の最小周期を返す",
			"     */",
			"    int max_repeat(bool multiple_only = false) {",
			"        for (int i = 1; i < n; i++) {",
			"            if (multiple_only && n % i != 0) continue;",
			"            if (n - i < i) break;",
			"            if (get(0, n - i) == get(i, n)) {",
			"                return i;",
			"            }",
			"        }",
			"        return n;",
			"    }",
			"",
			"    /**",
			"     * hash h を count 回結合",
			"     */",
			"    pair<ll, ll> times(pair<ll, ll> h, ll len, ll count) {",
			"        pair<ll, ll> ret = {0, 0}, now = h;",
			"        ll pw = 1;",
			"        while (count) {",
			"            if (count & 1) ret = concat(ret, now, len * pw);",
			"            now = concat(now, now, len * pw);",
			"            count >>= 1;",
			"            pw <<= 1;",
			"        }",
			"        return ret;",
			"    }",
			"",
			"   private:",
			"    template <class T>",
			"    static inline ll cv(const T &x) {",
			"        if constexpr (is_same_v<T, char> || is_same_v<T, signed char>) {",
			"            return (unsigned char)x;",
			"        } else if constexpr (is_same_v<T, unsigned char>) {",
			"            return (unsigned char)x;",
			"        } else {",
			"            return (ll)x;",
			"        }",
			"    }",
			"    static ll pow_mod(ll a, ll e, ll mod) {",
			"        ll r = 1 % mod;",
			"        a %= mod;",
			"        while (e > 0) {",
			"            if (e & 1) r = (r * a) % mod;",
			"            a = (a * a) % mod;",
			"            e >>= 1;",
			"        }",
			"        return r;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"RollingHashUpd": {
		"prefix": "RollingHashUpd",
		"body": [
			"struct RollingHashUpd {",
			"    /**",
			"     * ローリングハッシュ（変更クエリ）",
			"     * https://atcoder.jp/contests/abc331/submissions/72310134",
			"     */",
			"    static const ll base1 = 1009, base2 = 2009;",
			"    static const ll mod1 = 1000000007, mod2 = 1000000009;",
			"",
			"    struct Node {",
			"        ll hash1, hash2;",
			"        int len;",
			"        ll pow1, pow2;",
			"    };",
			"",
			"    static Node op(const Node &a, const Node &b) {",
			"        Node res;",
			"        res.len = a.len + b.len;",
			"        res.hash1 = (a.hash1 * b.pow1 + b.hash1) % mod1;",
			"        res.hash2 = (a.hash2 * b.pow2 + b.hash2) % mod2;",
			"        res.pow1 = (a.pow1 * b.pow1) % mod1;",
			"        res.pow2 = (a.pow2 * b.pow2) % mod2;",
			"        return res;",
			"    }",
			"",
			"    static Node e() { return {0, 0, 0, 1, 1}; }",
			"    atcoder::segtree<Node, op, e> seg;",
			"    vector<ll> s;",
			"    int n;",
			"",
			"    RollingHashUpd() = default;",
			"",
			"    template <typename Seq>",
			"    RollingHashUpd(const Seq &S) {",
			"        init(S);",
			"    }",
			"",
			"    template <typename Seq>",
			"    void init(const Seq &S) {",
			"        n = (int)S.size();",
			"        s.assign(n, 0);",
			"        vector<Node> init_data(n);",
			"        for (int i = 0; i < n; i++) {",
			"            ll x = cv(S[i]);",
			"            s[i] = x;",
			"            init_data[i] = {x, x, 1, base1 % mod1, base2 % mod2};",
			"        }",
			"        seg = atcoder::segtree<Node, op, e>(init_data);",
			"    }",
			"",
			"    pair<ll, ll> get(int l, int r) {",
			"        Node res = seg.prod(l, r);",
			"        return {res.hash1, res.hash2};",
			"    }",
			"",
			"    template <class V>",
			"    void change(int idx, const V &c) {",
			"        ll x = cv(c);",
			"        s[idx] = x;",
			"        Node newNode = {x, x, 1, base1 % mod1, base2 % mod2};",
			"        seg.set(idx, newNode);",
			"    }",
			"",
			"   private:",
			"    template <class T>",
			"    static inline ll cv(const T &x) {",
			"        if constexpr (is_same_v<T, char> || is_same_v<T, signed char>) {",
			"            return (unsigned char)x;",
			"        } else if constexpr (is_same_v<T, unsigned char>) {",
			"            return (unsigned char)x;",
			"        } else {",
			"            return (ll)x;",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"Mo": {
		"prefix": "Mo",
		"body": [
			"struct Mo {",
			"    /**",
			"     * Mo's algorithm",
			"     *",
			"     * usage:",
			"     * Mo mo(n);",
			"     * mo.add(l, r); // [l,r)",
			"     * auto add = [&](int i) { ... };",
			"     * auto erase = [&](int i) { ... };",
			"     * auto out = [&](int i) { ... };",
			"     * mo.build(add, erase, out);",
			"     *",
			"     * https://atcoder.jp/contests/abc242/submissions/72307746",
			"     */",
			"",
			"    int n;",
			"    vector<pair<int, int>> lr;",
			"",
			"    explicit Mo(int n) : n(n) {}",
			"",
			"    void add(int l, int r) {",
			"        // [l, r)",
			"        lr.emplace_back(l, r);",
			"    }",
			"",
			"    template <typename AL, typename AR, typename EL, typename ER, typename O>",
			"    void build(const AL &add_left, const AR &add_right, const EL &erase_left,",
			"               const ER &erase_right, const O &out) {",
			"        int q = (int)lr.size();",
			"        int bs = n / min<int>(n, sqrt(q));",
			"        vector<int> ord(q);",
			"        iota(begin(ord), end(ord), 0);",
			"        sort(begin(ord), end(ord), [&](int a, int b) {",
			"            int ablock = lr[a].first / bs, bblock = lr[b].first / bs;",
			"            if (ablock != bblock) return ablock < bblock;",
			"            return (ablock & 1) ? lr[a].second > lr[b].second",
			"                                : lr[a].second < lr[b].second;",
			"        });",
			"        int l = 0, r = 0;",
			"        for (auto idx : ord) {",
			"            while (l > lr[idx].first) add_left(--l);",
			"            while (r < lr[idx].second) add_right(r++);",
			"            while (l < lr[idx].first) erase_left(l++);",
			"            while (r > lr[idx].second) erase_right(--r);",
			"            out(idx);",
			"        }",
			"    }",
			"",
			"    template <typename A, typename E, typename O>",
			"    void build(const A &add, const E &erase, const O &out) {",
			"        build(add, add, erase, erase, out);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"MoRollback": {
		"prefix": "MoRollback",
		"body": [
			"struct MoRollback {",
			"    /**",
			"     * Mo's algorithm with rollback",
			"     *",
			"     * usage:",
			"     * MoRollback mo(n);",
			"     * mo.add(l, r); // [l,r)",
			"     * auto add  = [&](int i) { ... };",
			"     * auto snapshot  = [&]() { ... };",
			"     * auto rollback  = [&]() { ... };",
			"     * auto reset     = [&]() { ... };",
			"     * auto out       = [&](int qid) { ... };",
			"     * mo.build(add, snapshot, rollback, reset, out);",
			"     */",
			"",
			"    int n;",
			"    vector<pair<int, int>> lr;",
			"    vector<int> l, r;",
			"    explicit MoRollback(int n) : n(n) {}",
			"    void add(int li, int ri) { /* [l, r) */",
			"        l.emplace_back(li);",
			"        r.emplace_back(ri);",
			"    }",
			"    template <typename AL, typename AR, typename SS, typename RB, typename R,",
			"              typename O>",
			"    void build(const AL &add_left, const AR &add_right, const SS &snapshot,",
			"               const RB &rollback, const R &reset, const O &out) {",
			"        int q = (int)l.size();",
			"        int width = sqrt(n);",
			"        vector<int> qi(q);",
			"        iota(begin(qi), end(qi), 0);",
			"        sort(begin(qi), end(qi), [&](int i, int j) {",
			"            int ablock = l[i] / width, bblock = l[j] / width;",
			"            if (ablock != bblock) return ablock < bblock;",
			"            return r[i] < r[j];",
			"        });",
			"        snapshot();",
			"        for (auto idx : qi) {",
			"            if (r[idx] - l[idx] < width) {",
			"                for (int i = l[idx]; i < r[idx]; i++) add_right(i);",
			"                out(idx);",
			"                rollback();",
			"            }",
			"        }",
			"        int nr = 0, last_block = -1;",
			"        for (auto idx : qi) {",
			"            if (r[idx] - l[idx] < width) continue;",
			"            int block = l[idx] / width;",
			"            if (last_block != block) {",
			"                reset();",
			"                last_block = block;",
			"                nr = (block + 1) * width;",
			"            }",
			"            while (nr < r[idx]) add_right(nr++);",
			"            snapshot();",
			"            for (int j = (block + 1) * width - 1; j >= l[idx]; j--) add_left(j);",
			"            out(idx);",
			"            rollback();",
			"        }",
			"    }",
			"    template <typename A, typename SS, typename RB, typename R, typename O>",
			"    void build(const A &add, const SS &snapshot, const RB &rollback,",
			"               const R &reset, const O &out) {",
			"        build(add, add, snapshot, rollback, reset, out);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"PrioritySum": {
		"prefix": "PrioritySum",
		"body": [
			"template <typename T, typename Compare = less<T>,",
			"          typename RCompare = greater<T> >",
			"struct PrioritySumStructure {",
			"    // https://atcoder.jp/contests/arc210/submissions/72310300",
			"    int k;",
			"    T sum;",
			"",
			"    priority_queue<T, vector<T>, Compare> in, d_in;",
			"    priority_queue<T, vector<T>, RCompare> out, d_out;",
			"",
			"    PrioritySumStructure(int k) : k(k), sum(0) {}",
			"",
			"    void modify() {",
			"        while (in.size() - d_in.size() < k && !out.empty()) {",
			"            auto p = out.top();",
			"            out.pop();",
			"            if (!d_out.empty() && p == d_out.top()) {",
			"                d_out.pop();",
			"            } else {",
			"                sum += p;",
			"                in.emplace(p);",
			"            }",
			"        }",
			"        while (in.size() - d_in.size() > k) {",
			"            auto p = in.top();",
			"            in.pop();",
			"            if (!d_in.empty() && p == d_in.top()) {",
			"                d_in.pop();",
			"            } else {",
			"                sum -= p;",
			"                out.emplace(p);",
			"            }",
			"        }",
			"        while (!d_in.empty() && in.top() == d_in.top()) {",
			"            in.pop();",
			"            d_in.pop();",
			"        }",
			"    }",
			"",
			"    T query() const { return sum; }",
			"",
			"    void insert(T x) {",
			"        in.emplace(x);",
			"        sum += x;",
			"        modify();",
			"    }",
			"",
			"    void erase(T x) {",
			"        assert(size());",
			"        if (!in.empty() && in.top() == x) {",
			"            sum -= x;",
			"            in.pop();",
			"        } else if (!in.empty() && RCompare()(in.top(), x)) {",
			"            sum -= x;",
			"            d_in.emplace(x);",
			"        } else {",
			"            d_out.emplace(x);",
			"        }",
			"        modify();",
			"    }",
			"",
			"    void set_k(int kk) {",
			"        k = kk;",
			"        modify();",
			"    }",
			"",
			"    void inc_k() { set_k(k + 1); }",
			"",
			"    void dec_k() { set_k(k - 1); }",
			"",
			"    int get_k() const { return k; }",
			"",
			"    int size() const {",
			"        return in.size() + out.size() - d_in.size() - d_out.size();",
			"    }",
			"};",
			"",
			"template <typename T>",
			"using MaximumSum = PrioritySumStructure<T, greater<T>, less<T> >;",
			"",
			"template <typename T>",
			"using MinimumSum = PrioritySumStructure<T, less<T>, greater<T> >;",
			"",
		],
		"description": ""
	},
	"Matrix": {
		"prefix": "Matrix",
		"body": [
			"template <class T>",
			"struct Matrix {",
			"    // https://atcoder.jp/contests/jsc2021/submissions/72244560",
			"    vector<vector<T>> A;",
			"",
			"    Matrix() {}",
			"",
			"    Matrix(size_t n, size_t m) : A(n, std::vector<T>(m, zero())) {}",
			"",
			"    Matrix(size_t n) : A(n, std::vector<T>(n, zero())) {};",
			"",
			"    T zero() { return (T(0)); }",
			"",
			"    size_t height() const { return (A.size()); }",
			"",
			"    size_t width() const { return (A[0].size()); }",
			"",
			"    inline const vector<T> &operator[](int k) const { return (A.at(k)); }",
			"",
			"    inline vector<T> &operator[](int k) { return (A.at(k)); }",
			"",
			"    static Matrix I(size_t n) {",
			"        Matrix mat(n);",
			"        for (int i = 0; i < n; i++) mat[i][i] = 1;",
			"        return (mat);",
			"    }",
			"",
			"    Matrix &operator+=(const Matrix &B) {",
			"        size_t n = height(), m = width();",
			"        assert(n == B.height() && m == B.width());",
			"        for (int i = 0; i < n; i++)",
			"            for (int j = 0; j < m; j++) (*this)[i][j] += B[i][j];",
			"        return (*this);",
			"    }",
			"",
			"    Matrix &operator-=(const Matrix &B) {",
			"        size_t n = height(), m = width();",
			"        assert(n == B.height() && m == B.width());",
			"        for (int i = 0; i < n; i++)",
			"            for (int j = 0; j < m; j++) (*this)[i][j] -= B[i][j];",
			"        return (*this);",
			"    }",
			"",
			"    Matrix &operator*=(const Matrix &B) {",
			"        size_t n = height(), m = B.width(), p = width();",
			"        assert(p == B.height());",
			"        vector<vector<T>> C(n, vector<T>(m, zero()));",
			"        for (int i = 0; i < n; i++)",
			"            for (int j = 0; j < m; j++)",
			"                for (int k = 0; k < p; k++)",
			"                    C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);",
			"        A.swap(C);",
			"        return (*this);",
			"    }",
			"",
			"    Matrix &operator^=(long long k) {",
			"        Matrix B = Matrix::I(height());",
			"        while (k > 0) {",
			"            if (k & 1) B *= *this;",
			"            *this *= *this;",
			"            k >>= 1LL;",
			"        }",
			"        A.swap(B.A);",
			"        return (*this);",
			"    }",
			"",
			"    Matrix operator+(const Matrix &B) const { return (Matrix(*this) += B); }",
			"",
			"    Matrix operator-(const Matrix &B) const { return (Matrix(*this) -= B); }",
			"",
			"    Matrix operator*(const Matrix &B) const { return (Matrix(*this) *= B); }",
			"",
			"    Matrix operator^(const long long k) const { return (Matrix(*this) ^= k); }",
			"",
			"    bool operator==(const Matrix &B) const {",
			"        size_t n = height(), m = width();",
			"        if (n != B.height() || m != B.width()) return false;",
			"        for (int i = 0; i < n; i++)",
			"            for (int j = 0; j < m; j++)",
			"                if ((*this)[i][j] != B[i][j]) return false;",
			"        return true;",
			"    }",
			"",
			"    friend ostream &operator<<(ostream &os, Matrix &p) {",
			"        size_t n = p.height(), m = p.width();",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < m; j++) {",
			"                os << p[i][j] << (j + 1 == m ? \"\\n\" : \" \");",
			"            }",
			"        }",
			"        return (os);",
			"    }",
			"",
			"    T determinant() {  // O(n^3)",
			"        Matrix B(*this);",
			"        assert(width() == height());",
			"        T ret = 1;",
			"        for (int i = 0; i < width(); i++) {",
			"            int idx = -1;",
			"            for (int j = i; j < width(); j++) {",
			"                if (B[j][i] != 0) idx = j;",
			"            }",
			"            if (idx == -1) return (0);",
			"            if (i != idx) {",
			"                ret *= -1;",
			"                swap(B[i], B[idx]);",
			"            }",
			"            ret *= B[i][i];",
			"            T vv = B[i][i];",
			"            for (int j = 0; j < width(); j++) {",
			"                B[i][j] /= vv;",
			"            }",
			"            for (int j = i + 1; j < width(); j++) {",
			"                T a = B[j][i];",
			"                for (int k = 0; k < width(); k++) {",
			"                    B[j][k] -= B[i][k] * a;",
			"                }",
			"            }",
			"        }",
			"        return (ret);",
			"    }",
			"};",
			"",
			"template <typename T = long long>",
			"struct CC {",
			"    bool initialized;",
			"    vector<T> xs;",
			"    CC() : initialized(false) {}",
			"    void add(T x) { xs.push_back(x); }",
			"    void init() {",
			"        sort(xs.begin(), xs.end());",
			"        xs.erase(unique(xs.begin(), xs.end()), xs.end());",
			"        initialized = true;",
			"    }",
			"    int operator()(T x) {",
			"        if (!initialized) init();",
			"        return upper_bound(xs.begin(), xs.end(), x) - xs.begin() - 1;",
			"    }",
			"    T operator[](int i) {",
			"        if (!initialized) init();",
			"        return xs[i];",
			"    }",
			"    int size() {",
			"        if (!initialized) init();",
			"        return xs.size();",
			"    }",
			"};",
			"",
			"vector<vector<int>> remake(int n, vector<vector<int>> a) {",
			"    dsu uf(n);",
			"    rep(i, 0, n) rep(j, 0, i) {",
			"        if (a[i][j] == 1) {",
			"            if (uf.same(i, j)) return {};",
			"            uf.merge(i, j);",
			"        }",
			"    }",
			"    vector<int> u, v;",
			"    rep(i, 0, n) rep(j, 0, i) {",
			"        if (a[i][j] == -1 && !uf.same(i, j)) {",
			"            u.push_back(uf.leader(i));",
			"            v.push_back(uf.leader(j));",
			"        }",
			"    }",
			"    CC<int> cc;",
			"    for (auto x : u) cc.add(x);",
			"    for (auto x : v) cc.add(x);",
			"    for (auto &x : u) x = cc(x);",
			"    for (auto &x : v) x = cc(x);",
			"    int m = uf.groups().size();",
			"    vector<vector<int>> ret(m, vector<int>(m));",
			"    rep(i, 0, u.size()) {",
			"        ret[u[i]][v[i]]++;",
			"        ret[v[i]][u[i]]++;",
			"    }",
			"    return ret;",
			"}",
			"",
		],
		"description": ""
	},
	"MatrixFast": {
		"prefix": "MatrixFast",
		"body": [
			"const int mx = 10;",
			"",
			"template <class T>",
			"struct MatrixFast {",
			"    static const int h = mx, w = mx;",
			"    array<array<T, h>, w> A;",
			"",
			"    MatrixFast() {}",
			"",
			"    MatrixFast(size_t n, size_t m) {",
			"        assert(n == h && m == w);",
			"        for (int i = 0; i < h; i++) {",
			"            for (int j = 0; j < w; j++) {",
			"                A[i][j] = zero();",
			"            }",
			"        }",
			"    }",
			"",
			"    MatrixFast(size_t n) {",
			"        assert(n == h && n == w);",
			"        for (int i = 0; i < h; i++) {",
			"            for (int j = 0; j < w; j++) {",
			"                A[i][j] = zero();",
			"            }",
			"        }",
			"    }",
			"",
			"    T zero() { return (T(0)); }",
			"",
			"    size_t height() const { return h; }",
			"",
			"    size_t width() const { return w; }",
			"",
			"    inline const array<T, h> &operator[](int k) const { return A[k]; }",
			"",
			"    inline array<T, h> &operator[](int k) { return A[k]; }",
			"",
			"    static MatrixFast I(size_t n) {",
			"        MatrixFast mat(n);",
			"        for (size_t i = 0; i < n; i++) mat[i][i] = 1;",
			"        return (mat);",
			"    }",
			"",
			"    MatrixFast &operator+=(const MatrixFast &B) {",
			"        size_t n = height(), m = width();",
			"        assert(n == B.height() && m == B.width());",
			"        for (size_t i = 0; i < n; i++)",
			"            for (size_t j = 0; j < m; j++) (*this)[i][j] += B[i][j];",
			"        return (*this);",
			"    }",
			"",
			"    MatrixFast &operator-=(const MatrixFast &B) {",
			"        size_t n = height(), m = width();",
			"        assert(n == B.height() && m == B.width());",
			"        for (int i = 0; i < n; i++)",
			"            for (int j = 0; j < m; j++) (*this)[i][j] -= B[i][j];",
			"        return (*this);",
			"    }",
			"",
			"    MatrixFast &operator*=(const MatrixFast &B) {",
			"        size_t n = height(), m = B.width(), p = width();",
			"        assert(p == B.height());",
			"        MatrixFast C(n, m);",
			"        for (size_t i = 0; i < n; i++)",
			"            for (size_t j = 0; j < m; j++)",
			"                for (size_t k = 0; k < p; k++)",
			"                    C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);",
			"        swap(A, C.A);",
			"        return (*this);",
			"    }",
			"",
			"    MatrixFast &operator^=(long long k) {",
			"        MatrixFast B = MatrixFast::I(height());",
			"        while (k > 0) {",
			"            if (k & 1) B *= *this;",
			"            *this *= *this;",
			"            k >>= 1LL;",
			"        }",
			"        A.swap(B.A);",
			"        return (*this);",
			"    }",
			"",
			"    MatrixFast operator+(const MatrixFast &B) const {",
			"        return (MatrixFast(*this) += B);",
			"    }",
			"",
			"    MatrixFast operator-(const MatrixFast &B) const {",
			"        return (MatrixFast(*this) -= B);",
			"    }",
			"",
			"    MatrixFast operator*(const MatrixFast &B) const {",
			"        return (MatrixFast(*this) *= B);",
			"    }",
			"",
			"    MatrixFast operator^(const long long k) const {",
			"        return (MatrixFast(*this) ^= k);",
			"    }",
			"",
			"    bool operator==(const MatrixFast &B) const {",
			"        size_t n = height(), m = width();",
			"        if (n != B.height() || m != B.width()) return false;",
			"        for (size_t i = 0; i < n; i++)",
			"            for (size_t j = 0; j < m; j++)",
			"                if ((*this)[i][j] != B[i][j]) return false;",
			"        return true;",
			"    }",
			"",
			"    friend ostream &operator<<(ostream &os, MatrixFast &p) {",
			"        size_t n = p.height(), m = p.width();",
			"        for (size_t i = 0; i < n; i++) {",
			"            for (size_t j = 0; j < m; j++) {",
			"                os << p[i][j] << (j + 1 == m ? \"\\n\" : \" \");",
			"            }",
			"        }",
			"        return (os);",
			"    }",
			"",
			"    T determinant() {  // O(n^3)",
			"        MatrixFast B(*this);",
			"        assert(width() == height());",
			"        T ret = 1;",
			"        for (int i = 0; i < width(); i++) {",
			"            int idx = -1;",
			"            for (int j = i; j < width(); j++) {",
			"                if (B[j][i] != 0) idx = j;",
			"            }",
			"            if (idx == -1) return (0);",
			"            if (i != idx) {",
			"                ret *= -1;",
			"                swap(B[i], B[idx]);",
			"            }",
			"            ret *= B[i][i];",
			"            T vv = B[i][i];",
			"            for (int j = 0; j < width(); j++) {",
			"                B[i][j] /= vv;",
			"            }",
			"            for (int j = i + 1; j < width(); j++) {",
			"                T a = B[j][i];",
			"                for (int k = 0; k < width(); k++) {",
			"                    B[j][k] -= B[i][k] * a;",
			"                }",
			"            }",
			"        }",
			"        return (ret);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"WarshallFloyd": {
		"prefix": "WarshallFloyd",
		"body": [
			"template <typename T>",
			"struct WarshallFloyd {",
			"    int n;",
			"    vector<vector<T>> dist;",
			"    bool is_build = false;",
			"",
			"    WarshallFloyd() {}",
			"    WarshallFloyd(int n) : n(n), dist(n, vector<T>(n, inf())) {",
			"        for (int i = 0; i < n; i++) dist[i][i] = 0;",
			"    }",
			"    T inf() { return numeric_limits<T>::max() / 3; }",
			"    T chmin(T &a, T b) {",
			"        if (a > b) {",
			"            a = b;",
			"            return true;",
			"        }",
			"        return false;",
			"    }",
			"    void add_edge(int from, int to, T cost) {",
			"        assert(!is_build);",
			"        chmin(dist[from][to], cost);",
			"    }",
			"    bool add_edge_after_build(int from, int to, T cost) {",
			"        assert(is_build);",
			"        bool ret = chmin(dist[from][to], cost);",
			"        if (ret) {",
			"            for (int i = 0; i < n; i++) {",
			"                for (int j = 0; j < n; j++) {",
			"                    chmin(dist[i][j], dist[i][from] + cost + dist[to][j]);",
			"                    chmin(dist[i][j], dist[i][to] + cost + dist[from][j]);",
			"                }",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"    void build() {",
			"        assert(!is_build);",
			"        is_build = true;",
			"        for (int k = 0; k < n; k++)",
			"            for (int i = 0; i < n; i++)",
			"                for (int j = 0; j < n; j++)",
			"                    chmin(dist[i][j], dist[i][k] + dist[k][j]);",
			"    }",
			"    bool has_negative_cycle() {",
			"        assert(is_build);",
			"        for (int i = 0; i < n; i++)",
			"            if (dist[i][i] < 0) return true;",
			"        return false;",
			"    }",
			"    T solve(int from, int to) {",
			"        assert(is_build);",
			"        return dist[from][to];",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"UnionFindWeight": {
		"prefix": "UnionFindWeight",
		"body": [
			"template <typename T>",
			"struct UnionFindWeight {",
			"    // https://atcoder.jp/contests/abc087/submissions/72306519",
			"    vector<int> par;",
			"    vector<int> rank;",
			"    vector<T> diff_weight;",
			"",
			"    UnionFindWeight(int n = 1, T zero = 0) { reset(n, zero); }",
			"",
			"    void reset(int n = 1, T zero = 0) {",
			"        par.resize(n);",
			"        rank.resize(n);",
			"        diff_weight.resize(n);",
			"        for (int i = 0; i < n; ++i)",
			"            par[i] = i, rank[i] = 0, diff_weight[i] = zero;",
			"    }",
			"",
			"    int root(int x) {",
			"        if (par[x] == x) {",
			"            return x;",
			"        } else {",
			"            int r = root(par[x]);",
			"            diff_weight[x] += diff_weight[par[x]];",
			"            return par[x] = r;",
			"        }",
			"    }",
			"",
			"    T weight(int x) {",
			"        root(x);",
			"        return diff_weight[x];",
			"    }",
			"",
			"    bool same(int x, int y) { return root(x) == root(y); }",
			"",
			"    bool unite(int x, int y, T w) {  // x ----(距離 w)---- y",
			"        w += weight(x);",
			"        w -= weight(y);",
			"        x = root(x);",
			"        y = root(y);",
			"        if (x == y && w != 0) return false;",
			"        if (x == y) return true;",
			"        if (rank[x] == rank[y]) ++rank[x];",
			"        par[y] = x;",
			"        diff_weight[y] = w;",
			"        return true;",
			"    }",
			"",
			"    T dist(int x, int y) { return weight(y) - weight(x); }",
			"};",
			"",
		],
		"description": ""
	},
	"UnionFindRollBack": {
		"prefix": "UnionFindRollBack",
		"body": [
			"struct UnionFindRollBack {",
			"    vector<int> d;",
			"    vector<pair<int, int>> hist;",
			"    vector<int> snap, size_hist;",
			"    int subsize;",
			"    UnionFindRollBack(int n = 0) : d(n, -1) { subsize = n; }",
			"    int find(int x) {",
			"        if (d[x] < 0) return x;",
			"        return find(d[x]);",
			"    }",
			"    bool merge(int x, int y) {",
			"        x = find(x);",
			"        y = find(y);",
			"        if (x == y) return false;",
			"        subsize--;",
			"        if (d[x] > d[y]) swap(x, y);",
			"        hist.emplace_back(x, d[x]);",
			"        d[x] += d[y];",
			"        hist.emplace_back(y, d[y]);",
			"        d[y] = x;",
			"        return true;",
			"    }",
			"    bool same(int x, int y) { return find(x) == find(y); }",
			"    int size(int x) { return -d[find(x)]; }",
			"    void snapshot() {",
			"        snap.push_back(hist.size());",
			"        size_hist.push_back(subsize);",
			"    }",
			"    void rollback() {",
			"        while (hist.size() > snap.back()) {",
			"            auto [i, x] = hist.back();",
			"            hist.pop_back();",
			"            d[i] = x;",
			"        }",
			"        snap.pop_back();",
			"        subsize = size_hist.back();",
			"        size_hist.pop_back();",
			"    }",
			"};",
		],
		"description": ""
	},
	"Doubling": {
		"prefix": "Doubling",
		"body": [
			"template <class T>",
			"struct Doubling {",
			"    /**",
			"     * ダブリング",
			"     * next[i] = {(遷移先, 遷移コスト)}",
			"     * https://atcoder.jp/contests/abc438/submissions/72305434",
			"     */",
			"    int n;",
			"    int maxLog;",
			"    vector<vector<pair<int, T>>> table;",
			"",
			"    Doubling(vector<pair<int, T>> next, long long maxSteps = (1LL << 62)) {",
			"        n = (int)next.size();",
			"        maxLog = 0;",
			"        for (long long s = maxSteps; s > 0; s >>= 1) ++maxLog;",
			"        table.assign(maxLog, vector<pair<int, T>>(n));",
			"        table[0] = next;",
			"        for (int k = 1; k < maxLog; k++) {",
			"            for (int v = 0; v < n; v++) {",
			"                int mid = table[k - 1][v].first;",
			"                int to = table[k - 1][mid].first;",
			"                T sum = table[k - 1][v].second;",
			"                sum += table[k - 1][mid].second;",
			"                table[k][v] = {to, sum};",
			"            }",
			"        }",
			"    }",
			"",
			"    T jump(int start, long long steps) {",
			"        T acc{};",
			"        int v = start;",
			"        for (int k = 0; k < maxLog && steps > 0; k++) {",
			"            if (steps & 1LL) {",
			"                acc += table[k][v].second;",
			"                v = table[k][v].first;",
			"            }",
			"            steps >>= 1;",
			"        }",
			"        return acc;",
			"        // return {v, acc};",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"LongImos": {
		"prefix": "LongImos",
		"body": [
			"struct LongImos {",
			"    // https://atcoder.jp/contests/abc188/submissions/72310380",
			"    ll n;",
			"    map<ll, ll> ma;",
			"    vector<ll> li, ri, sum;",
			"    ll inf;",
			"",
			"    LongImos(ll inf = 2e18) : inf(inf) { ma[inf] = 0; }",
			"    void add(ll l, ll r, ll c) {",
			"        // 閉区間 [l, r] に c を加算",
			"        ma[l] += c;",
			"        ma[r + 1] -= c;",
			"    }",
			"    void make() {",
			"        li = vector<ll>(0);",
			"        ri = vector<ll>(0);",
			"        sum = vector<ll>(0);",
			"        ll nowt = inf, nowc = 0;",
			"        for (auto p : ma) {",
			"            auto key = p.first;",
			"            auto val = p.second;",
			"            li.push_back(nowt);",
			"            ri.push_back(key - 1);",
			"            sum.push_back(nowc);",
			"            nowt = key;",
			"            nowc += val;",
			"        }",
			"    }",
			"    void out() {",
			"        rep(i, 0, li.size()) {",
			"            cout << li[i] << ' ' << ri[i] << ' ' << sum[i] << endl;",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"MaxFlowLowerBound": {
		"prefix": "MaxFlowLowerBound",
		"body": [
			"template <class Cap>",
			"struct MaxFlowLowerBound {",
			"    /**",
			"     * 最小流量制限つき最大流",
			"     * https://atcoder.jp/contests/abc285/submissions/72320411",
			"     */",
			"    static_assert(is_integral_v<Cap>);",
			"",
			"    int V;",
			"    Cap INF;",
			"",
			"    vector<Cap> demand;",
			"",
			"    struct Edge {",
			"        int from, to;",
			"        Cap low, high;",
			"    };",
			"    vector<Edge> edges;",
			"",
			"    MaxFlowLowerBound(int V) : V(V), demand(V, 0) {",
			"        INF = numeric_limits<Cap>::max() / 4;",
			"    }",
			"",
			"    void add_edge(int u, int v, Cap low, Cap high) {",
			"        assert(0 <= low && low <= high);",
			"        edges.push_back({u, v, low, high});",
			"        demand[u] -= low;",
			"        demand[v] += low;",
			"    }",
			"",
			"    pair<bool, Cap> feasible_flow(int s, int t, mf_graph<Cap>& mf_feas,",
			"                                  mf_graph<Cap>& mf_st) {",
			"        int SS = V, TT = V + 1;",
			"        mf_feas = mf_graph<Cap>(V + 2);",
			"        mf_st = mf_graph<Cap>(V);",
			"        for (auto& e : edges) {",
			"            mf_feas.add_edge(e.from, e.to, e.high - e.low);",
			"            mf_st.add_edge(e.from, e.to, e.high - e.low);",
			"        }",
			"        Cap need = 0;",
			"        for (int v = 0; v < V; v++) {",
			"            if (demand[v] > 0) {",
			"                mf_feas.add_edge(SS, v, demand[v]);",
			"                need += demand[v];",
			"            } else if (demand[v] < 0) {",
			"                mf_feas.add_edge(v, TT, -demand[v]);",
			"            }",
			"        }",
			"        int id_ts = mf_feas.add_edge(t, s, INF);",
			"        Cap f = mf_feas.flow(SS, TT);",
			"        if (f != need) return {false, 0};",
			"        int M = (int)edges.size();",
			"        for (int i = 0; i < M; i++) {",
			"            auto ef = mf_feas.get_edge(i);",
			"            mf_st.change_edge(i, ef.cap, ef.flow);",
			"        }",
			"        Cap base = mf_feas.get_edge(id_ts).flow;",
			"        return {true, base};",
			"    }",
			"",
			"    Cap max_flow(int s, int t) {",
			"        mf_graph<Cap> mf_feas, mf_st;",
			"        auto [ok, base] = feasible_flow(s, t, mf_feas, mf_st);",
			"        if (!ok) return -1;",
			"        return base + mf_st.flow(s, t);",
			"    }",
			"",
			"    Cap min_flow(int s, int t) {",
			"        mf_graph<Cap> mf_feas, mf_st;",
			"        auto [ok, base] = feasible_flow(s, t, mf_feas, mf_st);",
			"        if (!ok) return -1;",
			"        Cap cancel = mf_st.flow(t, s);",
			"        return base - cancel;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"TwoDimensionalSum": {
		"prefix": "TwoDimensionalSum",
		"body": [
			"template <typename T>",
			"struct TwoDimensionalSum {",
			"    /**",
			"     * 2次元累積和",
			"     *",
			"     * 計算量:",
			"     * add_point: O(1)",
			"     * make: O(HW)",
			"     * sum: O(1)",
			"     * https://atcoder.jp/contests/tessoku-book/submissions/72306307",
			"     */",
			"    int h = 0, w = 0;",
			"    vector<vector<T>> v;",
			"    vector<vector<T>> diff;",
			"    vector<vector<T>> s;",
			"",
			"    bool dirty = true;",
			"",
			"    TwoDimensionalSum() = default;",
			"    TwoDimensionalSum(int h, int w) : h(h), w(w) {",
			"        v.assign(h, vector<T>(w, T{}));",
			"        diff.assign(h + 1, vector<T>(w + 1, T{}));",
			"        s.assign(h + 1, vector<T>(w + 1, T{}));",
			"    }",
			"",
			"    void add_point(int i, int j, T c) {",
			"        v[i][j] += c;",
			"        dirty = true;",
			"    }",
			"",
			"    void add_point(int li, int ri, int lj, int rj, T c) {",
			"        if (li >= ri || lj >= rj) return;",
			"        diff[li][lj] += c;",
			"        diff[li][rj] -= c;",
			"        diff[ri][lj] -= c;",
			"        diff[ri][rj] += c;",
			"        dirty = true;",
			"    }",
			"",
			"    void make() {",
			"        if (!dirty) return;",
			"        for (int i = 0; i <= h; i++) {",
			"            for (int j = 1; j <= w; j++) diff[i][j] += diff[i][j - 1];",
			"        }",
			"        for (int j = 0; j <= w; j++) {",
			"            for (int i = 1; i <= h; i++) diff[i][j] += diff[i - 1][j];",
			"        }",
			"        for (int i = 0; i < h; i++) {",
			"            for (int j = 0; j < w; j++) v[i][j] += diff[i][j];",
			"        }",
			"        for (int i = 0; i <= h; i++) fill(diff[i].begin(), diff[i].end(), T{});",
			"        s.assign(h + 1, vector<T>(w + 1, T{}));",
			"        for (int i = 0; i < h; i++) {",
			"            for (int j = 0; j < w; j++) {",
			"                s[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + v[i][j];",
			"            }",
			"        }",
			"        dirty = false;",
			"    }",
			"",
			"    T sum(int li, int ri, int lj, int rj) {",
			"        if (li >= ri || lj >= rj) return T{};",
			"        if (dirty) make();",
			"        return s[ri][rj] - s[ri][lj] - s[li][rj] + s[li][lj];",
			"    }",
			"",
			"    T val(int i, int j) { return sum(i, i + 1, j, j + 1); }",
			"};",
			"",
		],
		"description": ""
	},
	"TwoDimensionalFenwickTree": {
		"prefix": "TwoDimensionalFenwickTree",
		"body": [
			"template <typename T>",
			"struct TwoDimensionalFenwickTree {",
			"    /**",
			"     * 二次元FenwickTree",
			"     *",
			"     * 計算量:",
			"     *  - add:   O(log H * log W)",
			"     *  - query: O(log H * log W)",
			"     *",
			"     * https://atcoder.jp/contests/tessoku-book/submissions/72262268",
			"     */",
			"    int h, w;",
			"    vector<fenwick_tree<T>> bit;",
			"",
			"    TwoDimensionalFenwickTree(int h, int w)",
			"        : h(h), w(w), bit(h, fenwick_tree<T>(w)) {}",
			"",
			"    void add(int x, int y, T v) {",
			"        for (int i = x; i < h; i |= i + 1) {",
			"            bit[i].add(y, v);",
			"        }",
			"    }",
			"",
			"    T sum(int x, int y) {",
			"        T res = 0;",
			"        for (int i = x - 1; i >= 0; i = (i & (i + 1)) - 1) {",
			"            res += bit[i].sum(0, y);",
			"        }",
			"        return res;",
			"    }",
			"",
			"    T sum(int xl, int xr, int yl, int yr) {",
			"        return sum(xr, yr) - sum(xl, yr) - sum(xr, yl) + sum(xl, yl);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"XorMaker": {
		"prefix": "XorMaker",
		"body": [
			"struct XorMaker {",
			"    // https://atcoder.jp/contests/abc283/submissions/52197821",
			"    bool is_sorted;",
			"    vector<long long> basis, basis_save;",
			"    long long mod;",
			"    XorMaker(long long mod = 998244353) : mod(mod) { is_sorted = false; }",
			"    void add(long long k) {",
			"        is_sorted = false;",
			"        for (auto b : basis)",
			"            if ((k ^ b) < k) k ^= b;",
			"        if (!k) return;",
			"        for (auto &&b : basis)",
			"            if ((k ^ b) < b) b ^= k;",
			"        if (k) basis.emplace_back(k);",
			"    }",
			"    void add(long long l, long long r) {",
			"        // 閉区間[l, r]",
			"        is_sorted = false;",
			"        long long w = r - l + 1;",
			"        int k = 0;",
			"        while (w > (1LL << (k + 1))) k++;",
			"        l >>= k;",
			"        r >>= k;",
			"        for (long long i = l; i <= r; i++) add(i << k);",
			"        for (int i = 0; i < k; i++) add(1LL << i);",
			"    }",
			"    bool can_make(long long k) {",
			"        rep(i, 0, basis.size()) k = min(k, k ^ basis[i]);",
			"        return k == 0;",
			"    }",
			"    long long operator[](long long k) {",
			"        if (!is_sorted) {",
			"            sort(basis.begin(), basis.end());",
			"            is_sorted = true;",
			"        }",
			"        int bs = basis.size();",
			"        if (k >= (1LL << bs)) return -1;",
			"        if (k == -1) k = (1LL << bs) - 1;",
			"        long long ret = 0;",
			"        for (int i = 0; i < bs; i++) {",
			"            if (k & (1LL << i)) ret ^= basis[i];",
			"        }",
			"        return ret;",
			"    }",
			"    void snapshot() { basis_save = basis; }",
			"    void rollback() { basis = basis_save; }",
			"    void reset() { basis.clear(); }",
			"};",
			"",
		],
		"description": ""
	},
	"BigFact": {
		"prefix": "BigFact",
		"body": [
			"struct BigFact {",
			"    long long mod;",
			"    using mint = modint;",
			"",
			"    BigFact(long long mod = 998244353) : mod(mod) { mint::set_mod(mod); }",
			"",
			"    vector<long long> uku = {",
			"        1,         295201906, 160030060, 957629942, 545208507, 213689172,",
			"        760025067, 939830261, 506268060, 39806322,  808258749, 440133909,",
			"        686156489, 741797144, 390377694, 12629586,  544711799, 104121967,",
			"        495867250, 421290700, 117153405, 57084755,  202713771, 675932866,",
			"        79781699,  956276337, 652678397, 35212756,  655645460, 468129309,",
			"        761699708, 533047427, 287671032, 206068022, 50865043,  144980423,",
			"        111276893, 259415897, 444094191, 593907889, 573994984, 892454686,",
			"        566073550, 128761001, 888483202, 251718753, 548033568, 428105027,",
			"        742756734, 546182474, 62402409,  102052166, 826426395, 159186619,",
			"        926316039, 176055335, 51568171,  414163604, 604947226, 681666415,",
			"        511621808, 924112080, 265769800, 955559118, 763148293, 472709375,",
			"        19536133,  860830935, 290471030, 851685235, 242726978, 169855231,",
			"        612759169, 599797734, 961628039, 953297493, 62806842,  37844313,",
			"        909741023, 689361523, 887890124, 380694152, 669317759, 367270918,",
			"        806951470, 843736533, 377403437, 945260111, 786127243, 80918046,",
			"        875880304, 364983542, 623250998, 598764068, 804930040, 24257676,",
			"        214821357, 791011898, 954947696, 183092975};",
			"",
			"    long long fact(long long n) {",
			"        if (n >= mod) return 0;",
			"        int am = n % 10000000;",
			"        int ka = (n / 10000000) * 10000000;",
			"        mint ret = uku[n / 10000000];",
			"        for (int i = ka + 1; i <= ka + am; i++) ret *= i;",
			"        return ret.val();",
			"    }",
			"",
			"    long long comb(long long n, long long k) {",
			"        if (k < 0 || k > n) return 0;",
			"        if (n - k < k) k = n - k;",
			"        long long l = n - k, r = n;",
			"        if (l / mod != r / mod) return 0;",
			"        l %= mod;",
			"        r %= mod;",
			"        mint ret = (long long)fact(r);",
			"        ret /= (long long)fact(l);",
			"        ret /= (long long)fact(k);",
			"        return ret.val();",
			"    }",
			"",
			"    void uku_make(long long mod) {",
			"        mint::set_mod(mod);",
			"        mint now = 1;",
			"        vector<long long> uki;",
			"        rep(i, 1, mod) {",
			"            if ((i - 1) % 10000000 == 0) uki.push_back(now.val());",
			"            now *= i;",
			"        }",
			"        cout << '{';",
			"        int m = (int)uki.size();",
			"        for (int i = 0; i < m; i++) {",
			"            if (i % 10 == 0) cout << endl;",
			"            if (i != m - 1)",
			"                cout << uki[i] << ',';",
			"            else",
			"                cout << uki[i] << \"};\" << endl;",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"Arg": {
		"prefix": "Arg",
		"body": [
			"struct Arg {",
			"    /**",
			"     * 原点から(x, y) への角度を表すクラス",
			"     * https://atcoder.jp/contests/typical90/submissions/72319056",
			"     */",
			"    ll x, y;",
			"    Arg(ll x, ll y) : x(x), y(y) {}",
			"    bool operator==(const Arg& a) const { return x * a.y == y * a.x; }",
			"    bool operator<(const Arg& a) const {",
			"        return (std::pair{0LL, 0LL} < std::pair{y, x}) ==",
			"                       (std::pair{0LL, 0LL} < std::pair{a.y, a.x})",
			"                   ? x * a.y > a.x * y",
			"                   : std::pair{y, x} > std::pair{a.y, a.x};",
			"    }",
			"    bool operator<=(const Arg& a) const { return *this == a || *this < a; }",
			"    bool operator>(const Arg& a) const { return !(*this <= a); }",
			"    bool operator>=(const Arg& a) const { return !(*this < a); }",
			"    ll dot(const Arg& a) { return x * a.x + y * a.y; }",
			"    Arg rotate90() { return Arg(-y, x); }",
			"    Arg rotate180() { return Arg(-x, -y); }",
			"    Arg rotate270() { return Arg(y, -x); }",
			"",
			"    int calc_just90cnt(vector<Arg>& v, Arg& a) {",
			"        // a と直交するベクトルの個数を数える",
			"        int ret = 0;",
			"        Arg r90 = a.rotate90();",
			"        Arg r270 = a.rotate270();",
			"        ret += upper_bound(v.begin(), v.end(), r90) -",
			"               lower_bound(v.begin(), v.end(), r90);",
			"        ret += upper_bound(v.begin(), v.end(), r270) -",
			"               lower_bound(v.begin(), v.end(), r270);",
			"        return ret;",
			"    }",
			"    int calc_under90cnt(vector<Arg>& v, Arg& a) {",
			"        // a となす角が90度以下のベクトルの個数を数える",
			"        int ret = 0;",
			"        Arg l = a.rotate270();",
			"        Arg r = a.rotate90();",
			"        if (l < r) {",
			"            ret += upper_bound(v.begin(), v.end(), r) -",
			"                   lower_bound(v.begin(), v.end(), l);",
			"        } else {",
			"            ret += v.size() - (lower_bound(v.begin(), v.end(), l) -",
			"                               upper_bound(v.begin(), v.end(), r));",
			"        }",
			"        return ret;",
			"    }",
			"    int calc_over90cnt(vector<Arg>& v, Arg& a) {",
			"        // a となす角が90度より大きいベクトルの個数を数える",
			"        int ret = v.size() - calc_under90cnt(v, a);",
			"        return ret;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"Fraction": {
		"prefix": "Fraction",
		"body": [
			"struct Fraction {",
			"    /**",
			"     * p / q",
			"     * https://atcoder.jp/contests/abc390/submissions/72321330",
			"     */",
			"    ll p, q;",
			"    Fraction(ll P = 0, ll Q = 1) : p(P), q(Q) {",
			"        ll g = gcd(p, q);",
			"        p /= g;",
			"        q /= g;",
			"    }",
			"    bool operator<(const Fraction &other) const {",
			"        return p * other.q < other.p * q;",
			"    }",
			"    bool operator<=(const Fraction &other) const {",
			"        return p * other.q <= other.p * q;",
			"    }",
			"    bool operator>(const Fraction &other) const {",
			"        return p * other.q > other.p * q;",
			"    }",
			"    bool operator>=(const Fraction &other) const {",
			"        return p * other.q >= other.p * q;",
			"    }",
			"    bool operator==(const Fraction &other) const {",
			"        return p * other.q == other.p * q;",
			"    }",
			"",
			"    Fraction operator+(const Fraction &other) const {",
			"        return Fraction(p * other.q + other.p * q, q * other.q);",
			"    }",
			"    Fraction operator-(const Fraction &other) const {",
			"        return Fraction(p * other.q - other.p * q, q * other.q);",
			"    }",
			"    Fraction operator*(const Fraction &other) const {",
			"        return Fraction(p * other.p, q * other.q);",
			"    }",
			"    Fraction operator/(const Fraction &other) const {",
			"        return Fraction(p * other.q, q * other.p);",
			"    }",
			"    Fraction operator+=(const Fraction &other) { return *this = *this + other; }",
			"    Fraction operator-=(const Fraction &other) { return *this = *this - other; }",
			"    Fraction operator*=(const Fraction &other) { return *this = *this * other; }",
			"    Fraction operator/=(const Fraction &other) { return *this = *this / other; }",
			"};",
			"",
		],
		"description": ""
	},
	"CartesianTree": {
		"prefix": "CartesianTree",
		"body": [
			"template <class T>",
			"struct CartesianTree {",
			"    // https://atcoder.jp/contests/arc212/submissions/72479985",
			"    int root;",
			"    vector<int> par, left, right;",
			"",
			"    CartesianTree() : root(0) {}",
			"    CartesianTree(const vector<T>& v)",
			"        : root(0), par(v.size(), -1), left(v.size(), -1), right(v.size(), -1) {",
			"        vector<int> st(v.size(), 0);",
			"        int top = 0;",
			"        for (int i = 1; i < v.size(); ++i) {",
			"            if (v[st[top]] > v[i]) {",
			"                while (top >= 1 && v[st[top - 1]] > v[i]) --top;",
			"                left[i] = st[top];",
			"                par[left[i]] = i;",
			"                if (top == 0) {",
			"                    root = i;",
			"                } else {",
			"                    par[i] = st[top - 1];",
			"                    right[par[i]] = i;",
			"                }",
			"                st[top] = i;",
			"            } else {",
			"                par[i] = st[top];",
			"                right[par[i]] = i;",
			"                st[++top] = i;",
			"            }",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"MakeBridges": {
		"prefix": "MakeBridges",
		"body": [
			"struct MakeBridges {",
			"    // https://atcoder.jp/contests/arc039/submissions/72482449",
			"    int n;",
			"    vector<vector<pair<int, int>>> g;",
			"    vector<int> ord, low;",
			"    int timer;",
			"    vector<int> bridges;",
			"",
			"    MakeBridges(int n) : n(n), g(n), ord(n, -1), low(n, -1), timer(0) {}",
			"",
			"    void add_edge(int a, int b, int id) {",
			"        if (a == b) return;",
			"        g[a].push_back({b, id});",
			"        g[b].push_back({a, id});",
			"    }",
			"",
			"    void dfs(int v, int parent_eid) {",
			"        ord[v] = low[v] = timer++;",
			"        for (auto [to, eid] : g[v]) {",
			"            if (eid == parent_eid) continue;",
			"            if (ord[to] == -1) {",
			"                dfs(to, eid);",
			"                low[v] = min(low[v], low[to]);",
			"                if (ord[v] < low[to]) {",
			"                    bridges.push_back(eid);",
			"                }",
			"            } else {",
			"                low[v] = min(low[v], ord[to]);",
			"            }",
			"        }",
			"    }",
			"",
			"    vector<int> solve() {",
			"        for (int i = 0; i < n; ++i) {",
			"            if (ord[i] == -1) dfs(i, -1);",
			"        }",
			"        sort(bridges.begin(), bridges.end());",
			"        return bridges;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"GraphConectivityDP": {
		"prefix": "GraphConectivityDP",
		"body": [
			"template <typename T>",
			"struct GraphConectivityDP {",
			"    /**",
			"     * 連結グラフの部分集合に関するDP",
			"     * 計算量: O(3^n)",
			"     * https://atcoder.jp/contests/abc213/submissions/72143460",
			"     *",
			"     * solve(d): d[i] は頂点集合 i に含まれる\"連結とは限らない\"場合のvalue",
			"     */",
			"    int n;",
			"    vector<int> u, v;",
			"",
			"    GraphConectivityDP(int n) : n(n) {}",
			"",
			"    void add_edge(int a, int b) {",
			"        u.push_back(a);",
			"        v.push_back(b);",
			"    }",
			"",
			"    vector<T> solve(vector<T> d) {",
			"        assert((int)d.size() == (1 << n));",
			"        vector<T> dp(1 << n);",
			"        rep(s, 0, 1 << n) {",
			"            dp[s] = d[s];",
			"            int x = s & -s;",
			"            for (int t = s; t; t = (t - 1) & s) {",
			"                if (t == s) continue;",
			"                if ((t & x) == 0) continue;",
			"                dp[s] -= dp[t] * d[s ^ t];",
			"            }",
			"        }",
			"        return dp;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"FPS": {
		"prefix": "FPS",
		"body": [
			"template <class T>",
			"struct FormalPowerSeries {",
			"    using value_type = T;",
			"    std::vector<T> a;",
			"    FormalPowerSeries() = default;",
			"    explicit FormalPowerSeries(int n) : a(n, T(0)) {}",
			"    FormalPowerSeries(const std::vector<T>& v) : a(v) { shrink(); }",
			"    FormalPowerSeries(std::vector<T>&& v) : a(std::move(v)) { shrink(); }",
			"    FormalPowerSeries(std::initializer_list<T> init) : a(init) { shrink(); }",
			"    int size() const { return (int)a.size(); }",
			"    bool empty() const { return a.empty(); }",
			"    void clear() { a.clear(); }",
			"    void resize(int n) { a.resize(n, T(0)); }",
			"    void resize(int n, const T& v) { a.resize(n, v); }",
			"    auto begin() { return a.begin(); }",
			"    auto end() { return a.end(); }",
			"    auto begin() const { return a.begin(); }",
			"    auto end() const { return a.end(); }",
			"    void shrink() {",
			"        while (!a.empty() && a.back() == T(0)) a.pop_back();",
			"    }",
			"    T operator[](int i) const {",
			"        if (i < 0) return T(0);",
			"        return i < (int)a.size() ? a[i] : T(0);",
			"    }",
			"    T& operator[](int i) {",
			"        if (i < 0) throw std::out_of_range(\"FormalPowerSeries: negative index\");",
			"        if (i >= (int)a.size()) a.resize(i + 1, T(0));",
			"        return a[i];",
			"    }",
			"    FormalPowerSeries& operator+=(const FormalPowerSeries& rhs) {",
			"        if (rhs.size() > size()) a.resize(rhs.size(), T(0));",
			"        for (int i = 0; i < rhs.size(); i++) a[i] = a[i] + rhs.a[i];",
			"        shrink();",
			"        return *this;",
			"    }",
			"    FormalPowerSeries& operator-=(const FormalPowerSeries& rhs) {",
			"        if (rhs.size() > size()) a.resize(rhs.size(), T(0));",
			"        for (int i = 0; i < rhs.size(); i++) a[i] = a[i] - rhs.a[i];",
			"        shrink();",
			"        return *this;",
			"    }",
			"    FormalPowerSeries& operator*=(const T& c) {",
			"        for (auto& x : a) x = x * c;",
			"        shrink();",
			"        return *this;",
			"    }",
			"    FormalPowerSeries& operator/=(const T& c) {",
			"        require_inv_();",
			"        T ic = inv_scalar_(c);",
			"        for (auto& x : a) x = x * ic;",
			"        shrink();",
			"        return *this;",
			"    }",
			"    FormalPowerSeries& operator*=(const FormalPowerSeries& rhs) {",
			"        if (empty() || rhs.empty()) {",
			"            a.clear();",
			"            return *this;",
			"        }",
			"        a = convolution_impl_(a, rhs.a, -1);",
			"        shrink();",
			"        return *this;",
			"    }",
			"    FormalPowerSeries& operator/=(const FormalPowerSeries& rhs) {",
			"        *this = divmod(rhs).first;",
			"        return *this;",
			"    }",
			"    FormalPowerSeries& operator%=(const FormalPowerSeries& rhs) {",
			"        *this = divmod(rhs).second;",
			"        return *this;",
			"    }",
			"    friend FormalPowerSeries operator+(FormalPowerSeries l,",
			"                                       const FormalPowerSeries& r) {",
			"        return l += r;",
			"    }",
			"    friend FormalPowerSeries operator-(FormalPowerSeries l,",
			"                                       const FormalPowerSeries& r) {",
			"        return l -= r;",
			"    }",
			"    friend FormalPowerSeries operator*(FormalPowerSeries l,",
			"                                       const FormalPowerSeries& r) {",
			"        return l *= r;",
			"    }",
			"    friend FormalPowerSeries operator*(FormalPowerSeries l, const T& c) {",
			"        return l *= c;",
			"    }",
			"    friend FormalPowerSeries operator*(const T& c, FormalPowerSeries r) {",
			"        return r *= c;",
			"    }",
			"    friend FormalPowerSeries operator/(FormalPowerSeries l, const T& c) {",
			"        return l /= c;",
			"    }",
			"    friend FormalPowerSeries operator/(FormalPowerSeries l,",
			"                                       const FormalPowerSeries& r) {",
			"        return l /= r;",
			"    }",
			"    friend FormalPowerSeries operator%(FormalPowerSeries l,",
			"                                       const FormalPowerSeries& r) {",
			"        return l %= r;",
			"    }",
			"    FormalPowerSeries operator-() const {",
			"        FormalPowerSeries r = *this;",
			"        for (auto& x : r.a) x = T(0) - x;",
			"        r.shrink();",
			"        return r;",
			"    }",
			"    FormalPowerSeries pre(int k) const {",
			"        if (k <= 0 || empty()) return FormalPowerSeries();",
			"        if (size() <= k) return *this;",
			"        return FormalPowerSeries(std::vector<T>(a.begin(), a.begin() + k));",
			"    }",
			"    FormalPowerSeries mul_xk(int k) const {",
			"        if (k <= 0) return *this;",
			"        if (empty()) return FormalPowerSeries();",
			"        std::vector<T> r(k, T(0));",
			"        r.insert(r.end(), a.begin(), a.end());",
			"        return FormalPowerSeries(std::move(r));",
			"    }",
			"    FormalPowerSeries div_xk(int k) const {",
			"        if (k <= 0) return *this;",
			"        if (k >= size()) return FormalPowerSeries();",
			"        return FormalPowerSeries(std::vector<T>(a.begin() + k, a.end()));",
			"    }",
			"    friend FormalPowerSeries operator<<(FormalPowerSeries f, int k) {",
			"        return f.mul_xk(k);",
			"    }",
			"    friend FormalPowerSeries operator>>(FormalPowerSeries f, int k) {",
			"        return f.div_xk(k);",
			"    }",
			"    FormalPowerSeries mul_trunc(const FormalPowerSeries& rhs, int deg) const {",
			"        if (deg <= 0 || empty() || rhs.empty()) return FormalPowerSeries();",
			"        int n = std::min(size(), deg), m = std::min(rhs.size(), deg);",
			"        std::vector<T> x(a.begin(), a.begin() + n),",
			"            y(rhs.a.begin(), rhs.a.begin() + m);",
			"        auto res = convolution_impl_(x, y, deg);",
			"        if ((int)res.size() > deg) res.resize(deg);",
			"        FormalPowerSeries r(std::move(res));",
			"        r.shrink();",
			"        return r;",
			"    }",
			"    FormalPowerSeries derivative() const {",
			"        if (size() <= 1) return FormalPowerSeries();",
			"        std::vector<T> r(size() - 1);",
			"        for (int i = 1; i < size(); i++) r[i - 1] = a[i] * T(i);",
			"        return FormalPowerSeries(std::move(r));",
			"    }",
			"    FormalPowerSeries integral() const {",
			"        require_inv_();",
			"        std::vector<T> r(size() + 1, T(0));",
			"        for (int i = 0; i < size(); i++)",
			"            r[i + 1] = a[i] * inv_scalar_(T(i + 1));",
			"        FormalPowerSeries ret(std::move(r));",
			"        ret.shrink();",
			"        return ret;",
			"    }",
			"    T eval(const T& x) const {",
			"        T res = T(0), p = T(1);",
			"        for (int i = 0; i < size(); i++) {",
			"            res = res + a[i] * p;",
			"            p = p * x;",
			"        }",
			"        return res;",
			"    }",
			"    T dot(const FormalPowerSeries& rhs) const {",
			"        int n = std::min(size(), rhs.size());",
			"        T res = T(0);",
			"        for (int i = 0; i < n; i++) res = res + a[i] * rhs.a[i];",
			"        return res;",
			"    }",
			"    FormalPowerSeries rev(int deg = -1) const {",
			"        std::vector<T> r = a;",
			"        std::reverse(r.begin(), r.end());",
			"        if (deg != -1) {",
			"            if ((int)r.size() < deg)",
			"                r.resize(deg, T(0));",
			"            else",
			"                r.resize(deg);",
			"        }",
			"        FormalPowerSeries ret(std::move(r));",
			"        ret.shrink();",
			"        return ret;",
			"    }",
			"    FormalPowerSeries inv(int deg) const {",
			"        require_inv_();",
			"        if (deg <= 0) return FormalPowerSeries();",
			"        assert((*this)[0] != T(0));",
			"        FormalPowerSeries g({inv_scalar_((*this)[0])});",
			"        int n = 1;",
			"        while (n < deg) {",
			"            n <<= 1;",
			"            FormalPowerSeries fcut = this->pre(n);",
			"            FormalPowerSeries fg = fcut.mul_trunc(g, n);",
			"            FormalPowerSeries two({T(2)});",
			"            FormalPowerSeries inner = two - fg;",
			"            g = g.mul_trunc(inner, n);",
			"        }",
			"        return g.pre(deg);",
			"    }",
			"    FormalPowerSeries log(int deg) const {",
			"        require_inv_();",
			"        if (deg <= 0) return FormalPowerSeries();",
			"        assert((*this)[0] == T(1));",
			"        FormalPowerSeries f = this->pre(deg), fd = f.derivative(),",
			"                          invf = f.inv(deg);",
			"        FormalPowerSeries prod = fd.mul_trunc(invf, std::max(0, deg - 1));",
			"        FormalPowerSeries res = prod.integral();",
			"        return res.pre(deg);",
			"    }",
			"    FormalPowerSeries exp(int deg) const {",
			"        require_inv_();",
			"        if (deg <= 0) return FormalPowerSeries();",
			"        assert((*this)[0] == T(0));",
			"        FormalPowerSeries g({T(1)});",
			"        int n = 1;",
			"        while (n < deg) {",
			"            n <<= 1;",
			"            FormalPowerSeries glog = g.log(n);",
			"            FormalPowerSeries fcut = this->pre(n);",
			"            FormalPowerSeries diff = fcut - glog;",
			"            diff[0] = diff[0] + T(1);",
			"            g = g.mul_trunc(diff, n);",
			"        }",
			"        return g.pre(deg);",
			"    }",
			"    FormalPowerSeries pow(long long k, int deg = -1) const {",
			"        if (k < 0)",
			"            throw std::invalid_argument(",
			"                \"FormalPowerSeries::pow: negative exponent\");",
			"        if (deg == -1) {",
			"            if (empty()) return FormalPowerSeries();",
			"            __int128 d = (__int128)std::max(0, size() - 1) * (__int128)k + 1;",
			"            if (d <= 0) return FormalPowerSeries();",
			"            if (d > (__int128)std::numeric_limits<int>::max())",
			"                throw std::length_error(",
			"                    \"FormalPowerSeries::pow: degree too large\");",
			"            deg = (int)d;",
			"        }",
			"        if (deg <= 0) return FormalPowerSeries();",
			"        if (k == 0) return FormalPowerSeries({T(1)}).pre(deg);",
			"        if (empty()) return FormalPowerSeries();",
			"        if constexpr (has_inv<T>::value) {",
			"            int n = size(), i = 0;",
			"            while (i < n && (*this)[i] == T(0)) i++;",
			"            if (i == n) return FormalPowerSeries().pre(deg);",
			"            __int128 sh = (__int128)i * (__int128)k;",
			"            if (sh >= deg) return FormalPowerSeries().pre(deg);",
			"            T c = (*this)[i];",
			"            assert(c != T(0));",
			"            int newdeg = deg - (int)sh;",
			"            FormalPowerSeries g = this->div_xk(i);",
			"            g *= inv_scalar_(c);",
			"            g = g.pre(newdeg);",
			"            FormalPowerSeries lg = g.log(newdeg);",
			"            lg *= T(k);",
			"            FormalPowerSeries res = lg.exp(newdeg);",
			"            res *= pow_scalar_(c, k);",
			"            res = res.mul_xk((int)sh);",
			"            return res.pre(deg);",
			"        } else {",
			"            FormalPowerSeries base = this->pre(deg), res({T(1)});",
			"            long long e = k;",
			"            while (e > 0) {",
			"                if (e & 1) res = res.mul_trunc(base, deg);",
			"                e >>= 1;",
			"                if (e) base = base.mul_trunc(base, deg);",
			"            }",
			"            return res.pre(deg);",
			"        }",
			"    }",
			"    friend FormalPowerSeries operator^(const FormalPowerSeries& f,",
			"                                       long long k) {",
			"        return f.pow(k);",
			"    }",
			"    FormalPowerSeries& operator^=(long long k) {",
			"        *this = this->pow(k);",
			"        return *this;",
			"    }",
			"    FormalPowerSeries div_series(const FormalPowerSeries& g, int deg) const {",
			"        require_inv_();",
			"        if (deg <= 0) return FormalPowerSeries();",
			"        assert(g[0] != T(0));",
			"        return this->mul_trunc(g.inv(deg), deg);",
			"    }",
			"    std::pair<FormalPowerSeries, FormalPowerSeries> divmod(",
			"        const FormalPowerSeries& g) const {",
			"        require_inv_();",
			"        FormalPowerSeries f = *this, gg = g;",
			"        f.shrink();",
			"        gg.shrink();",
			"        if (gg.empty())",
			"            throw std::invalid_argument(",
			"                \"FormalPowerSeries::divmod: divide by zero polynomial\");",
			"        int n = f.size(), m = gg.size();",
			"        if (n < m) return {FormalPowerSeries(), f};",
			"        FormalPowerSeries rf = f.rev(), rg = gg.rev();",
			"        int k = n - m + 1;",
			"        assert(rg[0] != T(0));",
			"        FormalPowerSeries inv_rg = rg.inv(k);",
			"        FormalPowerSeries rq = rf.mul_trunc(inv_rg, k);",
			"        FormalPowerSeries q = rq.rev(k);",
			"        FormalPowerSeries r = f - (gg * q);",
			"        if (r.size() >= m) r.a.resize(std::max(0, m - 1), T(0));",
			"        r.shrink();",
			"        q.shrink();",
			"        return {q, r};",
			"    }",
			"    FormalPowerSeries sqrt(int deg) const {",
			"        require_inv_();",
			"        if (deg <= 0) return FormalPowerSeries();",
			"        FormalPowerSeries f = this->pre(deg);",
			"        if (f.empty()) return FormalPowerSeries(deg);",
			"        int i = 0;",
			"        while (i < (int)f.a.size() && f.a[i] == T(0)) i++;",
			"        if (i == (int)f.a.size()) return FormalPowerSeries(deg);",
			"        if (i & 1) return FormalPowerSeries();",
			"        int sh = i / 2;",
			"        if (sh >= deg) return FormalPowerSeries(deg);",
			"        int newdeg = deg - sh;",
			"        FormalPowerSeries g = f.div_xk(i).pre(newdeg);",
			"        T r0;",
			"        if (!sqrt_scalar_(g[0], r0)) return FormalPowerSeries();",
			"        FormalPowerSeries r({r0});",
			"        T inv2 = inv_scalar_(T(2));",
			"        int n = 1;",
			"        while (n < newdeg) {",
			"            int m = std::min(newdeg, n << 1);",
			"            FormalPowerSeries t = g.div_series(r, m);",
			"            r = (r + t) * inv2;",
			"            r = r.pre(m);",
			"            n = m;",
			"        }",
			"        r = r.mul_xk(sh).pre(deg);",
			"        r.shrink();",
			"        return r;",
			"    }",
			"    void ntt_inplace() {",
			"        require_ntt_();",
			"        int n = size();",
			"        assert(n > 0 && (n & (n - 1)) == 0);",
			"        atcoder::internal::butterfly(a);",
			"    }",
			"    void intt_inplace() {",
			"        require_ntt_();",
			"        int n = size();",
			"        assert(n > 0 && (n & (n - 1)) == 0);",
			"        atcoder::internal::butterfly_inv(a);",
			"        T invn = inv_scalar_(T(n));",
			"        for (auto& x : a) x = x * invn;",
			"        shrink();",
			"    }",
			"    FormalPowerSeries mul_ntt_only(const FormalPowerSeries& rhs) const {",
			"        require_ntt_();",
			"        return FormalPowerSeries(atcoder::convolution(a, rhs.a));",
			"    }",
			"",
			"   private:",
			"    template <class U, class = void>",
			"    struct is_acl_modint : std::false_type {};",
			"    template <class U>",
			"    struct is_acl_modint<",
			"        U, std::void_t<decltype(U::mod()), decltype(std::declval<U>().val())>>",
			"        : std::true_type {};",
			"    template <class U, class = void>",
			"    struct has_inv : std::false_type {};",
			"    template <class U>",
			"    struct has_inv<U, std::void_t<decltype(std::declval<U>().inv())>>",
			"        : std::true_type {};",
			"    template <class U, class = void>",
			"    struct has_constexpr_mod : std::false_type {};",
			"    template <class U>",
			"    struct has_constexpr_mod<",
			"        U, std::void_t<decltype(std::integral_constant<int, U::mod()>{})>>",
			"        : std::true_type {};",
			"    static constexpr int v2_constexpr(long long x) {",
			"        int r = 0;",
			"        while ((x & 1LL) == 0) {",
			"            x >>= 1;",
			"            r++;",
			"        }",
			"        return r;",
			"    }",
			"    static int bit_ceil(int x) {",
			"        int p = 1;",
			"        while (p < x) p <<= 1;",
			"        return p;",
			"    }",
			"    static void require_inv_() {",
			"        static_assert(",
			"            has_inv<T>::value,",
			"            \"This operation requires T::inv() (e.g. atcoder::modint).\");",
			"    }",
			"    static constexpr bool can_direct_ntt_() {",
			"        if constexpr (!is_acl_modint<T>::value) return false;",
			"        if constexpr (!has_constexpr_mod<T>::value) return false;",
			"        constexpr int MOD = T::mod();",
			"        constexpr int r2 = v2_constexpr((long long)MOD - 1);",
			"        return r2 >= 20;",
			"    }",
			"    static void require_ntt_() {",
			"        static_assert(",
			"            can_direct_ntt_(),",
			"            \"This operation requires an NTT-friendly static modint (e.g. \"",
			"            \"atcoder::modint998244353).\");",
			"    }",
			"    static T inv_scalar_(const T& x) { return x.inv(); }",
			"    static T pow_scalar_(T x, long long e) {",
			"        T r = T(1);",
			"        while (e > 0) {",
			"            if (e & 1LL) r = r * x;",
			"            e >>= 1LL;",
			"            if (e) x = x * x;",
			"        }",
			"        return r;",
			"    }",
			"    static uint64_t mod_mul_u64_(uint64_t a, uint64_t b, uint64_t mod) {",
			"        return (uint64_t)((__int128)a * (__int128)b % mod);",
			"    }",
			"    static uint64_t mod_pow_u64_(uint64_t a, uint64_t e, uint64_t mod) {",
			"        uint64_t r = 1;",
			"        while (e) {",
			"            if (e & 1) r = mod_mul_u64_(r, a, mod);",
			"            a = mod_mul_u64_(a, a, mod);",
			"            e >>= 1;",
			"        }",
			"        return r;",
			"    }",
			"    static bool is_prime_u64_(uint64_t n) {",
			"        if (n < 2) return false;",
			"        for (uint64_t p : {2ull, 3ull, 5ull, 7ull, 11ull, 13ull, 17ull, 19ull,",
			"                           23ull, 29ull, 31ull, 37ull}) {",
			"            if (n % p == 0) return n == p;",
			"        }",
			"        uint64_t d = n - 1, s = 0;",
			"        while ((d & 1) == 0) {",
			"            d >>= 1;",
			"            s++;",
			"        }",
			"        auto witness = [&](uint64_t a) -> bool {",
			"            uint64_t x = mod_pow_u64_(a, d, n);",
			"            if (x == 1 || x == n - 1) return false;",
			"            for (uint64_t r = 1; r < s; r++) {",
			"                x = mod_mul_u64_(x, x, n);",
			"                if (x == n - 1) return false;",
			"            }",
			"            return true;",
			"        };",
			"        for (uint64_t a : {2ull, 325ull, 9375ull, 28178ull, 450775ull,",
			"                           9780504ull, 1795265022ull}) {",
			"            if (a % n == 0) continue;",
			"            if (witness(a)) return false;",
			"        }",
			"        return true;",
			"    }",
			"    static bool sqrt_scalar_(const T& aa, T& out) {",
			"        if (aa == T(0)) {",
			"            out = T(0);",
			"            return true;",
			"        }",
			"        if constexpr (!is_acl_modint<T>::value) {",
			"            return false;",
			"        }",
			"        uint64_t p = (uint64_t)T::mod();",
			"        if (p == 2) {",
			"            out = aa;",
			"            return true;",
			"        }",
			"        if (!is_prime_u64_(p)) return false;",
			"        if (aa.pow((long long)((p - 1) / 2)) != T(1)) return false;",
			"        if ((p & 3ull) == 3ull) {",
			"            out = aa.pow((long long)((p + 1) / 4));",
			"            return true;",
			"        }",
			"        uint64_t q = p - 1;",
			"        int s = 0;",
			"        while ((q & 1ull) == 0ull) {",
			"            q >>= 1;",
			"            s++;",
			"        }",
			"        T z = T(0);",
			"        for (uint64_t c = 2; c < p; c++) {",
			"            T cand = T((long long)c);",
			"            if (cand.pow((long long)((p - 1) / 2)) == T((long long)p - 1)) {",
			"                z = cand;",
			"                break;",
			"            }",
			"        }",
			"        if (z == T(0)) return false;",
			"        T c = z.pow((long long)q);",
			"        T x = aa.pow((long long)((q + 1) / 2));",
			"        T t = aa.pow((long long)q);",
			"        int m = s;",
			"        while (t != T(1)) {",
			"            int i = 0;",
			"            T tt = t;",
			"            for (i = 0; i < m; i++) {",
			"                if (tt == T(1)) break;",
			"                tt = tt * tt;",
			"            }",
			"            if (i == m) return false;",
			"            T b = c.pow(1LL << (m - i - 1));",
			"            x = x * b;",
			"            T bb = b * b;",
			"            t = t * bb;",
			"            c = bb;",
			"            m = i;",
			"        }",
			"        out = x;",
			"        return true;",
			"    }",
			"    static std::vector<T> convolution_naive_(const std::vector<T>& x,",
			"                                             const std::vector<T>& y, int lim) {",
			"        if (x.empty() || y.empty()) return {};",
			"        int n = x.size(), m = y.size();",
			"        int full = n + m - 1;",
			"        int L = lim < 0 ? full : std::min(full, lim);",
			"        if (L <= 0) return {};",
			"        std::vector<T> res(L, T(0));",
			"        for (int i = 0; i < n; i++) {",
			"            int jmax = std::min(m, L - i);",
			"            for (int j = 0; j < jmax; j++)",
			"                res[i + j] = res[i + j] + x[i] * y[j];",
			"        }",
			"        return res;",
			"    }",
			"    static std::vector<T> convolution_crt_modint_(const std::vector<T>& x,",
			"                                                  const std::vector<T>& y) {",
			"        static_assert(is_acl_modint<T>::value, \"\");",
			"        static constexpr int MOD1 = 167772161, MOD2 = 469762049,",
			"                             MOD3 = 1224736769;",
			"        using m1 = atcoder::static_modint<MOD1>;",
			"        using m2 = atcoder::static_modint<MOD2>;",
			"        using m3 = atcoder::static_modint<MOD3>;",
			"        int n = x.size(), m = y.size();",
			"        std::vector<m1> a1(n), b1(m);",
			"        std::vector<m2> a2(n), b2(m);",
			"        std::vector<m3> a3(n), b3(m);",
			"        for (int i = 0; i < n; i++) {",
			"            int v = (int)x[i].val();",
			"            a1[i] = m1(v);",
			"            a2[i] = m2(v);",
			"            a3[i] = m3(v);",
			"        }",
			"        for (int i = 0; i < m; i++) {",
			"            int v = (int)y[i].val();",
			"            b1[i] = m1(v);",
			"            b2[i] = m2(v);",
			"            b3[i] = m3(v);",
			"        }",
			"        auto c1 = atcoder::convolution(a1, b1);",
			"        auto c2 = atcoder::convolution(a2, b2);",
			"        auto c3 = atcoder::convolution(a3, b3);",
			"        int L = c1.size();",
			"        std::vector<T> res(L);",
			"        const long long mm1 = MOD1, mm1m2 = 1LL * MOD1 * MOD2;",
			"        const int MODT = T::mod();",
			"        m2 inv_m1_mod_m2 = m2(mm1).inv();",
			"        m3 inv_m1m2_mod_m3 = m3(mm1m2).inv();",
			"        for (int i = 0; i < L; i++) {",
			"            long long x1v = c1[i].val();",
			"            long long x2v =",
			"                ((m2(c2[i].val()) - m2((int)x1v)) * inv_m1_mod_m2).val();",
			"            long long t = (long long)((__int128)mm1 * x2v);",
			"            long long x3v =",
			"                ((m3(c3[i].val()) - m3((int)x1v) - m3((int)(t % MOD3))) *",
			"                 inv_m1m2_mod_m3)",
			"                    .val();",
			"            __int128 exact =",
			"                (__int128)x1v + (__int128)mm1 * x2v + (__int128)mm1m2 * x3v;",
			"            long long ans = (long long)(exact % MODT);",
			"            if (ans < 0) ans += MODT;",
			"            res[i] = T(ans);",
			"        }",
			"        return res;",
			"    }",
			"    static std::vector<T> convolution_modint_auto_(const std::vector<T>& x,",
			"                                                   const std::vector<T>& y) {",
			"        if constexpr (has_constexpr_mod<T>::value) {",
			"            constexpr int MOD = T::mod();",
			"            constexpr int r2 = v2_constexpr((long long)MOD - 1);",
			"            int need = bit_ceil((int)x.size() + (int)y.size() - 1);",
			"            if (r2 >= 0 && (uint64_t)need <= (1ULL << r2))",
			"                return atcoder::convolution(x, y);",
			"            return convolution_crt_modint_(x, y);",
			"        } else",
			"            return convolution_crt_modint_(x, y);",
			"    }",
			"    static std::vector<T> convolution_impl_(const std::vector<T>& x,",
			"                                            const std::vector<T>& y, int lim) {",
			"        if (x.empty() || y.empty()) return {};",
			"        if constexpr (is_acl_modint<T>::value) {",
			"            auto r = convolution_modint_auto_(x, y);",
			"            if (lim >= 0 && (int)r.size() > lim) r.resize(lim);",
			"            return r;",
			"        } else if constexpr (std::is_integral<T>::value)",
			"            return convolution_naive_(x, y, lim);",
			"        else",
			"            return convolution_naive_(x, y, lim);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	// extend struct
	"dynamic_segtree": {
		"prefix": "dynamic_segtree",
		"body": [
			"template <class S, S (*op)(S, S), S (*e)()>",
			"class dynamic_segtree {",
			"    // https://atcoder.jp/contests/abc403/submissions/66024391",
			"   public:",
			"    dynamic_segtree(size_t n) : n(n), root(nullptr) {}",
			"",
			"    void set(size_t p, S x) {",
			"        assert(p < n);",
			"        set(root, 0, n, p, x);",
			"    }",
			"",
			"    S get(size_t p) const {",
			"        assert(p < n);",
			"        return get(root, 0, n, p);",
			"    }",
			"",
			"    S prod(size_t l, size_t r) const {",
			"        assert(l <= r && r <= n);",
			"        return prod(root, 0, n, l, r);",
			"    }",
			"",
			"    S all_prod() const { return root ? root->product : e(); }",
			"",
			"    void reset(size_t l, size_t r) {",
			"        assert(l <= r && r <= n);",
			"        return reset(root, 0, n, l, r);",
			"    }",
			"",
			"    template <bool (*f)(S)>",
			"    size_t max_right(size_t l) const {",
			"        return max_right(l, [](S x) { return f(x); });",
			"    }",
			"",
			"    template <class F>",
			"    size_t max_right(size_t l, const F &f) const {",
			"        assert(l <= n);",
			"        S product = e();",
			"        assert(f(product));",
			"        return max_right(root, 0, n, l, f, product);",
			"    }",
			"",
			"    template <bool (*f)(S)>",
			"    size_t min_left(size_t r) const {",
			"        return min_left(r, [](S x) { return f(x); });",
			"    }",
			"",
			"    template <class F>",
			"    size_t min_left(size_t r, const F &f) const {",
			"        assert(r <= n);",
			"        S product = e();",
			"        assert(f(product));",
			"        return min_left(root, 0, n, r, f, product);",
			"    }",
			"",
			"   private:",
			"    struct node;",
			"    using node_ptr = std::unique_ptr<node>;",
			"",
			"    struct node {",
			"        size_t index;",
			"        S value, product;",
			"        node_ptr left, right;",
			"",
			"        node(size_t index, S value)",
			"            : index(index),",
			"              value(value),",
			"              product(value),",
			"              left(nullptr),",
			"              right(nullptr) {}",
			"",
			"        void update() {",
			"            product = op(op(left ? left->product : e(), value),",
			"                         right ? right->product : e());",
			"        }",
			"    };",
			"",
			"    const size_t n;",
			"    node_ptr root;",
			"",
			"    void set(node_ptr &t, size_t a, size_t b, size_t p, S x) const {",
			"        if (!t) {",
			"            t = std::make_unique<node>(p, x);",
			"            return;",
			"        }",
			"        if (t->index == p) {",
			"            t->value = x;",
			"            t->update();",
			"            return;",
			"        }",
			"        size_t c = (a + b) >> 1;",
			"        if (p < c) {",
			"            if (t->index < p) std::swap(t->index, p), std::swap(t->value, x);",
			"            set(t->left, a, c, p, x);",
			"        } else {",
			"            if (p < t->index) std::swap(p, t->index), std::swap(x, t->value);",
			"            set(t->right, c, b, p, x);",
			"        }",
			"        t->update();",
			"    }",
			"",
			"    S get(const node_ptr &t, size_t a, size_t b, size_t p) const {",
			"        if (!t) return e();",
			"        if (t->index == p) return t->value;",
			"        size_t c = (a + b) >> 1;",
			"        if (p < c)",
			"            return get(t->left, a, c, p);",
			"        else",
			"            return get(t->right, c, b, p);",
			"    }",
			"",
			"    S prod(const node_ptr &t, size_t a, size_t b, size_t l, size_t r) const {",
			"        if (!t || b <= l || r <= a) return e();",
			"        if (l <= a && b <= r) return t->product;",
			"        size_t c = (a + b) >> 1;",
			"        S result = prod(t->left, a, c, l, r);",
			"        if (l <= t->index && t->index < r) result = op(result, t->value);",
			"        return op(result, prod(t->right, c, b, l, r));",
			"    }",
			"",
			"    void reset(node_ptr &t, size_t a, size_t b, size_t l, size_t r) const {",
			"        if (!t || b <= l || r <= a) return;",
			"        if (l <= a && b <= r) {",
			"            t.reset();",
			"            return;",
			"        }",
			"        size_t c = (a + b) >> 1;",
			"        reset(t->left, a, c, l, r);",
			"        reset(t->right, c, b, l, r);",
			"        t->update();",
			"    }",
			"",
			"    template <class F>",
			"    size_t max_right(const node_ptr &t, size_t a, size_t b, size_t l,",
			"                     const F &f, S &product) const {",
			"        if (!t || b <= l) return n;",
			"        if (f(op(product, t->product))) {",
			"            product = op(product, t->product);",
			"            return n;",
			"        }",
			"        size_t c = (a + b) >> 1;",
			"        size_t result = max_right(t->left, a, c, l, f, product);",
			"        if (result != n) return result;",
			"        if (l <= t->index) {",
			"            product = op(product, t->value);",
			"            if (!f(product)) return t->index;",
			"        }",
			"        return max_right(t->right, c, b, l, f, product);",
			"    }",
			"",
			"    template <class F>",
			"    size_t min_left(const node_ptr &t, size_t a, size_t b, size_t r, const F &f,",
			"                    S &product) const {",
			"        if (!t || r <= a) return 0;",
			"        if (f(op(t->product, product))) {",
			"            product = op(t->product, product);",
			"            return 0;",
			"        }",
			"        size_t c = (a + b) >> 1;",
			"        size_t result = min_left(t->right, c, b, r, f, product);",
			"        if (result != 0) return result;",
			"        if (t->index < r) {",
			"            product = op(t->value, product);",
			"            if (!f(product)) return t->index + 1;",
			"        }",
			"        return min_left(t->left, a, c, r, f, product);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"priority_queue_ex": {
		"prefix": "priority_queue_ex",
		"body": [
			"template <typename T, typename S = vector<T>, typename U = less<T>>",
			"struct priority_queue_ex {",
			"    priority_queue<T, S, U> q, dq;",
			"    void push(T x) { q.push(x); }",
			"    T top() {",
			"        while (dq.size() && q.top() == dq.top()) {",
			"            q.pop();",
			"            dq.pop();",
			"        }",
			"        return q.top();",
			"    }",
			"    T pop() {",
			"        T ret = top();",
			"        q.pop();",
			"        return ret;",
			"    }",
			"    void erase(T x) { dq.push(x); }",
			"    int size() { return q.size() - dq.size(); }",
			"    void out() {",
			"        priority_queue_ex<T, S, U> tmp;",
			"        tmp = *this;",
			"        while (tmp.size()) {",
			"            cout << tmp.top() << \" \";",
			"            tmp.pop();",
			"        }",
			"        cout << endl;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	// function
	"chmin": {
		"prefix": "chmin",
		"body": [
			"template <typename T, typename S>",
			"bool chmin(T &a, S b) {",
			"    if (a > b) {",
			"        a = b;",
			"        return 1;",
			"    }",
			"    return 0;",
			"}",
			"",
		],
		"description": ""
	},
	"chmax": {
		"prefix": "chmax",
		"body": [
			"template <typename T, typename S>",
			"bool chmax(T &a, S b) {",
			"    if (a < b) {",
			"        a = b;",
			"        return 1;",
			"    }",
			"    return 0;",
			"}",
			"",
		],
		"description": ""
	},
	"ceil_div": {
		"prefix": "ceil_div",
		"body": [
			"template <typename T> T ceil_div(T a, T b) {",
			"    if (b < 0)",
			"        a = -a, b = -b;",
			"    return (a >= 0 ? (a + b - 1) / b : a / b);",
			"}",
			"",
		],
		"description": ""
	},
	"floor_div": {
		"prefix": "floor_div",
		"body": [
			"template <typename T> T floor_div(T a, T b) {",
			"    if (b < 0)",
			"        a = -a, b = -b;",
			"    return (a >= 0 ? a / b : (a - b + 1) / b);",
			"}",
			"",
		],
		"description": ""
	},
	"smaller": {
		"prefix": "smaller",
		"body": [
			"template <typename T>",
			"int smaller(vector<T> &a, T x) {",
			"    return lower_bound(a.begin(), a.end(), x) - a.begin();",
			"}",
			"template <typename T>",
			"int or_smaller(vector<T> &a, T x) {",
			"    return upper_bound(a.begin(), a.end(), x) - a.begin();",
			"}",
			"template <typename T>",
			"int bigger(vector<T> &a, T x) {",
			"    return a.size() - or_smaller(a, x);",
			"}",
			"template <typename T>",
			"int or_bigger(vector<T> &a, T x) {",
			"    return a.size() - smaller(a, x);",
			"}",
			"",
		],
		"description": ""
	},
	"divisor": {
		"prefix": "divisor",
		"body": [
			"vector<ll> divisor(ll n) {",
			"    auto mod_mul = [](ll a, ll b, ll mod) -> ll {",
			"        return (__int128)a * b % mod;",
			"    };",
			"",
			"    auto mod_pow = [&](ll base, ll exp, ll mod) -> ll {",
			"        ll result = 1;",
			"        base %= mod;",
			"        while (exp) {",
			"            if (exp & 1) result = mod_mul(result, base, mod);",
			"            base = mod_mul(base, base, mod);",
			"            exp >>= 1;",
			"        }",
			"        return result;",
			"    };",
			"",
			"    auto is_prime = [&](ll num) -> bool {",
			"        if (num < 2) return false;",
			"        int smallPrimes[12] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};",
			"        for (int p : smallPrimes) {",
			"            if (num == p) return true;",
			"            if (num % p == 0) return false;",
			"        }",
			"        ll d = num - 1;",
			"        int s = 0;",
			"        while ((d & 1) == 0) {",
			"            d /= 2;",
			"            s++;",
			"        }",
			"        ll testPrimes[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
			"        for (ll a : testPrimes) {",
			"            if (a % num == 0) continue;",
			"            ll x = mod_pow(a, d, num);",
			"            if (x == 1 || x == num - 1) continue;",
			"            bool composite = true;",
			"            for (int i = 0; i < s - 1; i++) {",
			"                x = mod_mul(x, x, num);",
			"                if (x == num - 1) {",
			"                    composite = false;",
			"                    break;",
			"                }",
			"            }",
			"            if (composite) return false;",
			"        }",
			"        return true;",
			"    };",
			"",
			"    function<ll(ll)> pollard_rho;",
			"    pollard_rho = [&](ll num) -> ll {",
			"        if (num % 2 == 0) return 2;",
			"        mt19937_64 rng(random_device{}());",
			"        uniform_int_distribution<ll> dist(2, num - 2);",
			"        ll x = dist(rng), y = x, c = dist(rng), d = 1;",
			"        auto f = [&](ll x, ll c, ll mod) -> ll {",
			"            return (mod_mul(x, x, mod) + c) % mod;",
			"        };",
			"        while (d == 1) {",
			"            x = f(x, c, num);",
			"            y = f(y, c, num);",
			"            y = f(y, c, num);",
			"            d = gcd(abs(x - y), num);",
			"            if (d == num) return pollard_rho(num);",
			"        }",
			"        return d;",
			"    };",
			"",
			"    function<void(ll, vector<ll> &)> factorize;",
			"    factorize = [&](ll num, vector<ll> &factors) {",
			"        if (num == 1) return;",
			"        if (is_prime(num)) {",
			"            factors.push_back(num);",
			"            return;",
			"        }",
			"        ll factor = pollard_rho(num);",
			"        factorize(factor, factors);",
			"        factorize(num / factor, factors);",
			"    };",
			"",
			"    vector<ll> factors;",
			"    factorize(n, factors);",
			"    sort(factors.begin(), factors.end());",
			"    vector<pair<ll, int>> factorCounts;",
			"    for (ll f : factors) {",
			"        if (factorCounts.empty() || factorCounts.back().first != f)",
			"            factorCounts.push_back({f, 1});",
			"        else",
			"            factorCounts.back().second++;",
			"    }",
			"    vector<ll> divisors;",
			"    function<void(int, ll)> dfs = [&](int idx, ll current) {",
			"        if (idx == factorCounts.size()) {",
			"            divisors.push_back(current);",
			"            return;",
			"        }",
			"        ll prime = factorCounts[idx].first;",
			"        int exp = factorCounts[idx].second;",
			"        for (int i = 0; i <= exp; i++) {",
			"            dfs(idx + 1, current);",
			"            current *= prime;",
			"        }",
			"    };",
			"    dfs(0, 1);",
			"    sort(divisors.begin(), divisors.end());",
			"    return divisors;",
			"}",
			"",
		],
		"description": ""
	},
	"factorize": {
		"prefix": "factorize",
		"body": [
			"vector<ll> factorize(ll n) {",
			"    vector<ll> factors;",
			"",
			"    auto mod_mul = [](ll a, ll b, ll mod) -> ll {",
			"        return (__int128)a * b % mod;",
			"    };",
			"",
			"    auto mod_pow = [&](ll base, ll exp, ll mod) -> ll {",
			"        ll result = 1;",
			"        base %= mod;",
			"        while (exp) {",
			"            if (exp & 1) result = mod_mul(result, base, mod);",
			"            base = mod_mul(base, base, mod);",
			"            exp >>= 1;",
			"        }",
			"        return result;",
			"    };",
			"",
			"    auto is_prime = [&](ll num) -> bool {",
			"        if (num < 2) return false;",
			"        int smallPrimes[12] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};",
			"        for (int p : smallPrimes) {",
			"            if (num == p) return true;",
			"            if (num % p == 0) return false;",
			"        }",
			"        ll d = num - 1;",
			"        int s = 0;",
			"        while ((d & 1) == 0) {",
			"            d /= 2;",
			"            s++;",
			"        }",
			"        ll testPrimes[7] = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};",
			"        for (ll a : testPrimes) {",
			"            if (a % num == 0) continue;",
			"            ll x = mod_pow(a, d, num);",
			"            if (x == 1 || x == num - 1) continue;",
			"            bool composite = true;",
			"            for (int i = 0; i < s - 1; i++) {",
			"                x = mod_mul(x, x, num);",
			"                if (x == num - 1) {",
			"                    composite = false;",
			"                    break;",
			"                }",
			"            }",
			"            if (composite) return false;",
			"        }",
			"        return true;",
			"    };",
			"",
			"    function<ll(ll)> pollard_rho;",
			"    pollard_rho = [&](ll num) -> ll {",
			"        if (num % 2 == 0) return 2;",
			"        mt19937_64 rng(random_device{}());",
			"        uniform_int_distribution<ll> dist(2, num - 2);",
			"        ll x = dist(rng), y = x, c = dist(rng), d = 1;",
			"        auto f = [&](ll x, ll c, ll mod) -> ll {",
			"            return (mod_mul(x, x, mod) + c) % mod;",
			"        };",
			"        while (d == 1) {",
			"            x = f(x, c, num);",
			"            y = f(y, c, num);",
			"            y = f(y, c, num);",
			"            d = gcd(abs(x - y), num);",
			"            if (d == num) return pollard_rho(num);",
			"        }",
			"        return d;",
			"    };",
			"",
			"    function<void(ll)> recursive_factorize;",
			"    recursive_factorize = [&](ll num) {",
			"        if (num == 1) return;",
			"        if (is_prime(num)) {",
			"            factors.push_back(num);",
			"            return;",
			"        }",
			"        ll factor = pollard_rho(num);",
			"        recursive_factorize(factor);",
			"        recursive_factorize(num / factor);",
			"    };",
			"",
			"    recursive_factorize(n);",
			"    sort(factors.begin(), factors.end());",
			"    return factors;",
			"}",
			"",
		],
		"description": ""
	},
	"LIS": {
		"prefix": "LIS",
		"body": [
			"template <typename T>",
			"vector<T> LIS(const vector<T> &a, bool strict) {",
			"    int n = a.size();",
			"    vector<T> d_vals;",
			"    vector<int> d_idx;",
			"    vector<int> parent(n, -1);",
			"    for (int i = 0; i < n; i++) {",
			"        int pos;",
			"        if (strict) {",
			"            pos = lower_bound(d_vals.begin(), d_vals.end(), a[i]) -",
			"                  d_vals.begin();",
			"        } else {",
			"            pos = upper_bound(d_vals.begin(), d_vals.end(), a[i]) -",
			"                  d_vals.begin();",
			"        }",
			"        if (pos == (int)d_vals.size()) {",
			"            d_vals.push_back(a[i]);",
			"            d_idx.push_back(i);",
			"        } else {",
			"            d_vals[pos] = a[i];",
			"            d_idx[pos] = i;",
			"        }",
			"        if (pos > 0) {",
			"            parent[i] = d_idx[pos - 1];",
			"        }",
			"    }",
			"    vector<T> lis;",
			"    int cur = d_idx.back();",
			"    while (cur != -1) {",
			"        lis.push_back(a[cur]);",
			"        cur = parent[cur];",
			"    }",
			"    reverse(lis.begin(), lis.end());",
			"    return lis;",
			"}",
			"",
		],
		"description": ""
	},
	"inv_num": {
		"prefix": "inv_num",
		"body": [
			"template <typename T>",
			"long long inv_num(vector<T> &a) {",
			"    int n = a.size();",
			"    long long ret = 0;",
			"    vector<pair<T, int>> p(n);",
			"    fenwick_tree<long long> d(n);",
			"    rep(i, 0, n) p[i] = make_pair(a[i], i);",
			"    sort(p.begin(), p.end());",
			"    rep(i, 0, n) {",
			"        ret += i - d.sum(0, p[i].second);",
			"        d.add(p[i].second, 1);",
			"    }",
			"    return ret;",
			"}",
			"",
		],
		"description": ""
	},
	"convolution_any_mod": {
		"prefix": "convolution_any_mod",
		"body": [
			"vector<modint> convolution_any_mod(const vector<modint>& a,",
			"                                   const vector<modint>& b) {",
			"    int n = (int)a.size(), m = (int)b.size();",
			"    if (n == 0 || m == 0) return {};",
			"    vector<modint> res(n + m - 1);",
			"    if (min(n, m) <= 100) {",
			"        for (int i = 0; i < n; i++) {",
			"            for (int j = 0; j < m; j++) {",
			"                res[i + j] += a[i] * b[j];",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    using mint1 = static_modint<167772161>;",
			"    using mint2 = static_modint<469762049>;",
			"    using mint3 = static_modint<1224736769>;",
			"    vector<long long> a_ll(n), b_ll(m);",
			"    for (int i = 0; i < n; i++) a_ll[i] = a[i].val();",
			"    for (int i = 0; i < m; i++) b_ll[i] = b[i].val();",
			"    vector<long long> x = convolution<167772161>(a_ll, b_ll);",
			"    vector<long long> y = convolution<469762049>(a_ll, b_ll);",
			"    vector<long long> z = convolution<1224736769>(a_ll, b_ll);",
			"    const long long m1 = 167772161LL;",
			"    const long long m2 = 469762049LL;",
			"    const long long m1_inv_m2 = mint2(m1).inv().val();",
			"    const long long m12_inv_m3 = mint3(m1 * m2).inv().val();",
			"    const long long mod = modint::mod();",
			"    const long long m12_mod = (m1 * m2) % mod;",
			"    for (int i = 0; i < n + m - 1; i++) {",
			"        long long v1 = (mint2(y[i] - x[i]) * m1_inv_m2).val();",
			"        long long t = (x[i] + m1 * v1) % 1224736769LL;",
			"        long long v2 = (mint3(z[i] - t) * m12_inv_m3).val();",
			"        res[i] = modint(x[i]) + modint(m1) * v1 + modint(m12_mod) * v2;",
			"    }",
			"    return res;",
			"}",
			"",
		],
		"description": ""
	},
	"rand_ll": {
		"prefix": "rand_ll",
		"body": [
			"static inline long long rand_ll(long long n) {",
			"    static unsigned int tx = 123456789u, ty = 362436069u, tz = 521288629u,",
			"                        tw = 88675123u;",
			"    static bool init = false;",
			"    if (!init) {",
			"        auto seed = (unsigned long long)std::chrono::steady_clock::now()",
			"                        .time_since_epoch()",
			"                        .count();",
			"        tx ^= (unsigned int)(seed);",
			"        ty ^= (unsigned int)(seed >> 16);",
			"        tz ^= (unsigned int)(seed >> 32);",
			"        tw ^= (unsigned int)(seed >> 48);",
			"        init = true;",
			"    }",
			"    unsigned int t = tx ^ (tx << 11);",
			"    tx = ty;",
			"    ty = tz;",
			"    tz = tw;",
			"    unsigned int r = (tw = (tw ^ (tw >> 19)) ^ (t ^ (t >> 8)));",
			"    return (long long)((unsigned long long)r % (unsigned long long)n);",
			"}",
			"",
		],
		"description": ""
	},
	"submasks": {
		"prefix": "submasks",
		"body": [
			"vector<int> submasks(int n) {",
			"    vector<int> ret;",
			"    for (int sm = n;; sm = (sm - 1) & n) {",
			"        ret.push_back(sm);",
			"        if (sm == 0) break;",
			"    }",
			"    reverse(ret.begin(), ret.end());",
			"    return ret;",
			"}",
			"",
		],
		"description": ""
	},
	"convex_hull": {
		"prefix": "convex_hull",
		"body": [
			"template <class T>",
			"vector<pair<T, T>> convex_hull(vector<pair<T, T>> pts) {",
			"    // https://atcoder.jp/contests/typical90/submissions/71641592",
			"    if (pts.size() <= 1) return pts;",
			"    sort(pts.begin(), pts.end());",
			"    pts.erase(unique(pts.begin(), pts.end()), pts.end());",
			"    if (pts.size() <= 2) return pts;",
			"    auto cross = [](auto const &a, auto const &b, auto const &c) {",
			"        return (b.first - a.first) * (c.second - a.second) -",
			"               (b.second - a.second) * (c.first - a.first);",
			"    };",
			"    vector<pair<T, T>> hull;",
			"    hull.reserve(pts.size() * 2);",
			"    for (auto const &p : pts) {",
			"        while (hull.size() >= 2 &&",
			"               cross(hull[hull.size() - 2], hull[hull.size() - 1], p) <= 0) {",
			"            hull.pop_back();",
			"        }",
			"        hull.push_back(p);",
			"    }",
			"    size_t lower_size = hull.size();",
			"    for (auto it = pts.rbegin(); it != pts.rend(); ++it) {",
			"        while (hull.size() >= lower_size + 1 &&",
			"               cross(hull[hull.size() - 2], hull[hull.size() - 1], *it) <= 0) {",
			"            hull.pop_back();",
			"        }",
			"        hull.push_back(*it);",
			"    }",
			"    hull.pop_back();",
			"    return hull;",
			"}",
			"",
		],
		"description": ""
	},
	"is_prime": {
		"prefix": "is_prime",
		"body": [
			"#include <boost/multiprecision/miller_rabin.hpp>",
			"",
			"bool is_prime(long long n) {",
			"    if (boost::multiprecision::miller_rabin_test(n, 20))",
			"        return true;",
			"    else",
			"        return false;",
			"}",
			"",
		],
		"description": ""
	},
	// other
	"binary": {
		"prefix": "binary",
		"body": [
			"    auto check = [&](ll mid) {",
			"        int border = 573;",
			"        return mid <= border;",
			"    };",
			"    auto binary = [&]() {",
			"        ll ac = 0, wa = 1e9;",
			"        while (llabs(ac - wa) > 1) {",
			"            ll mid = ac + (wa - ac) / 2;",
			"            if (check(mid)) {",
			"                ac = mid;",
			"            } else {",
			"                wa = mid;",
			"            }",
			"        }",
			"        return ac;",
			"    };",
			"",
		],
		"description": ""
	},
	"binaryd": {
		"prefix": "binaryd",
		"body": [
			"    auto check = [&](double x) { return x <= 57.3; };",
			"    auto binary = [&]() {",
			"        int trial_ct = 80;",
			"        double ac = 0.0, wa = 1e9;",
			"        while (trial_ct--) {",
			"            double mid = ac + (wa - ac) / 2.0;",
			"            if (check(mid)) {",
			"                ac = mid;",
			"            } else {",
			"                wa = mid;",
			"            }",
			"        }",
			"        return ac;",
			"    };",
			"",
		],
		"description": ""
	},
	"vout": {
		"prefix": "vout",
		"body": [
			"template <typename T>",
			"ostream &operator<<(ostream &os, const vector<T> &v) {",
			"    int n = v.size();",
			"    rep(i, 0, n) { os << v[i] << \" \\n\"[i == n - 1]; }",
			"    return os;",
			"}",
			"",
		],
		"description": ""
	},
	// not practical
	"CountIncreasingSequences": {
		"prefix": "CountIncreasingSequences",
		"body": [
			"template <typename T>",
			"struct CountIncreasingSequences {",
			"    /*",
			"     * 長さ n の数列 a = [a_0, ..., a_{n-1}] が与えられる。",
			"     * 各 i について 1 <= b_i <= a_i を満たす長さ n の数列 b を考える。",
			"     * b が単調非減少（b_0 <= b_1 <= ... <= b_{n-1}）となるものの個数を数える。",
			"     * https://atcoder.jp/contests/arc104/submissions/72107875",
			"     */",
			"",
			"    template <typename S = long long>",
			"    struct CCC {",
			"        bool initialized;",
			"        vector<S> xs;",
			"        CCC() : initialized(false) {}",
			"        void add(S x) { xs.push_back(x); }",
			"        void init() {",
			"            sort(xs.begin(), xs.end());",
			"            xs.erase(unique(xs.begin(), xs.end()), xs.end());",
			"            initialized = true;",
			"        }",
			"        int operator()(S x) {",
			"            if (!initialized) init();",
			"            return upper_bound(xs.begin(), xs.end(), x) - xs.begin() - 1;",
			"        }",
			"        S operator[](int i) {",
			"            if (!initialized) init();",
			"            return xs[i];",
			"        }",
			"        int size() {",
			"            if (!initialized) init();",
			"            return xs.size();",
			"        }",
			"    };",
			"",
			"    T comb(ll n, ll k) {",
			"        if (k < 0 || k > n) return 0;",
			"        if (k > n - k) k = n - k;",
			"        T ret = 1;",
			"        rep(i, 0, k) ret *= n - i;",
			"        rep(i, 1, k + 1) ret /= i;",
			"        return ret;",
			"    }",
			"",
			"    T solve(vector<ll> &a) {",
			"        CCC<ll> cc;",
			"        for (auto v : a) cc.add(v);",
			"        cc.add(0);",
			"        int n = a.size();",
			"        int h = cc.size();",
			"        vector<vector<T>> dp(h + 1, vector<T>(n + 1, 0));",
			"        dp[0][0] = 1;",
			"        rep(i, 0, h) {",
			"            ll nh = cc[i + 1];",
			"            ll delta = cc[i + 1] - cc[i];",
			"            rep(j, 0, n) {",
			"                dp[i + 1][j] += dp[i][j];",
			"                rep(k, j, n) {",
			"                    bool valid = 1;",
			"                    for (int id = j; id <= k; id++) valid &= (a[id] >= nh);",
			"                    if (!valid) continue;",
			"                    dp[i + 1][k + 1] += dp[i][j] * comb(delta, k - j + 1);",
			"                }",
			"            }",
			"        }",
			"        T ret = 0;",
			"        rep(i, 0, h + 1) ret += dp[i][n];",
			"        return ret;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"RangeSetQuery": {
		"prefix": "RangeSetQuery",
		"body": [
			"template <typename T>",
			"struct RangeSetQuery {",
			"    // https://atcoder.jp/contests/abc174/submissions/71632215",
			"    int n;",
			"    vector<T> val;",
			"    vector<int> prev_occ;",
			"    vector<vector<int>> bit;",
			"    unordered_map<T, set<int>> pos;",
			"",
			"    RangeSetQuery() {}",
			"    RangeSetQuery(int size) { init(size); }",
			"    RangeSetQuery(const vector<T> &vec) { build(vec); }",
			"",
			"    inline void bit_add(int i, int oldv, int newv) {",
			"        for (++i; i <= n; i += i & -i) {",
			"            auto &v = bit[i];",
			"            if (oldv != INT_MIN) {",
			"                auto it = lower_bound(v.begin(), v.end(), oldv);",
			"                if (it != v.end() && *it == oldv) v.erase(it);",
			"            }",
			"            if (newv != INT_MIN) {",
			"                v.insert(lower_bound(v.begin(), v.end(), newv), newv);",
			"            }",
			"        }",
			"    }",
			"",
			"    inline int bit_query(int r, int x) const {",
			"        int res = 0;",
			"        for (; r > 0; r -= r & -r) {",
			"            auto &v = bit[r];",
			"            res += lower_bound(v.begin(), v.end(), x) - v.begin();",
			"        }",
			"        return res;",
			"    }",
			"",
			"    void init(int size) {",
			"        n = size;",
			"        val.assign(n, T());",
			"        prev_occ.assign(n, -1);",
			"        bit.assign(n + 1, {});",
			"        pos.clear();",
			"    }",
			"",
			"    void build(const vector<T> &vec) {",
			"        n = vec.size();",
			"        val = vec;",
			"        prev_occ.assign(n, -1);",
			"        pos.clear();",
			"        bit.assign(n + 1, {});",
			"",
			"        for (int i = 0; i < n; i++) pos[val[i]].insert(i);",
			"",
			"        for (auto &kv : pos) {",
			"            auto &S = kv.second;",
			"            int last = -1;",
			"            for (int p : S) {",
			"                prev_occ[p] = last;",
			"                last = p;",
			"            }",
			"        }",
			"",
			"        for (int p = 0; p < n; p++) {",
			"            int pr = prev_occ[p];",
			"            for (int i = p + 1; i <= n; i += i & -i) {",
			"                bit[i].push_back(pr);",
			"            }",
			"        }",
			"",
			"        for (int i = 1; i <= n; i++) {",
			"            auto &v = bit[i];",
			"            sort(v.begin(), v.end());",
			"        }",
			"    }",
			"",
			"    void update(int p, T newv) {",
			"        T oldv = val[p];",
			"        if (oldv == newv) return;",
			"",
			"        auto &Sold = pos[oldv];",
			"        auto it = Sold.find(p);",
			"",
			"        int old_prev = prev_occ[p];",
			"        int old_next = -1;",
			"        {",
			"            auto it2 = it;",
			"            ++it2;",
			"            if (it2 != Sold.end()) old_next = *it2;",
			"        }",
			"",
			"        Sold.erase(it);",
			"",
			"        val[p] = newv;",
			"",
			"        auto &Snew = pos[newv];",
			"        auto it_new = Snew.insert(p).first;",
			"",
			"        int new_prev = -1, new_next = -1;",
			"        if (it_new != Snew.begin()) {",
			"            auto itp = it_new;",
			"            --itp;",
			"            new_prev = *itp;",
			"        }",
			"        {",
			"            auto itn = it_new;",
			"            ++itn;",
			"            if (itn != Snew.end()) new_next = *itn;",
			"        }",
			"",
			"        if (old_next != -1) {",
			"            int old_prev_oldnext = prev_occ[old_next];",
			"            prev_occ[old_next] = old_prev;",
			"            bit_add(old_next, old_prev_oldnext, old_prev);",
			"        }",
			"",
			"        if (new_next != -1) {",
			"            int old_prev_oldnext = prev_occ[new_next];",
			"            prev_occ[new_next] = p;",
			"            bit_add(new_next, old_prev_oldnext, p);",
			"        }",
			"",
			"        bit_add(p, prev_occ[p], new_prev);",
			"        prev_occ[p] = new_prev;",
			"    }",
			"",
			"    int solve(int l, int r) { return bit_query(r, l) - bit_query(l, l); }",
			"};",
			"",
		],
		"description": ""
	},
	"PrefixCombSum": {
		"prefix": "PrefixCombSum",
		"body": [
			"struct PrefixCombSum {",
			"    int n;",
			"    vector<pair<int, int>> lr;",
			"    vector<mint> ans;",
			"    mint div2;",
			"",
			"    PrefixCombSum() {}",
			"    PrefixCombSum(int max_input) : n(max_input) { div2 = mint(1) / 2; }",
			"",
			"    void add_query(int n, int k) {",
			"        // Σ_{i=0~k} nCi",
			"        lr.emplace_back(n, k);",
			"    }",
			"",
			"    vector<mint> solve() {",
			"        int q = (int)lr.size();",
			"        int bs = n / min<int>(n, sqrt(q));",
			"        ans.resize(q);",
			"        vector<int> ord(q);",
			"        iota(begin(ord), end(ord), 0);",
			"        sort(begin(ord), end(ord), [&](int a, int b) {",
			"            int ablock = lr[a].first / bs, bblock = lr[b].first / bs;",
			"            if (ablock != bblock) return ablock < bblock;",
			"            return (ablock & 1) ? lr[a].second > lr[b].second",
			"                                : lr[a].second < lr[b].second;",
			"        });",
			"        int l = 0, r = 0;",
			"        mint nw = 1;",
			"        for (auto idx : ord) {",
			"            while (l > lr[idx].first) {",
			"                nw += comb(l - 1, r);",
			"                nw *= div2;",
			"                l--;",
			"            }",
			"            while (r < lr[idx].second) {",
			"                nw += comb(l, r + 1);",
			"                r++;",
			"            }",
			"            while (l < lr[idx].first) {",
			"                nw *= 2;",
			"                nw -= comb(l, r);",
			"                l++;",
			"            }",
			"            while (r > lr[idx].second) {",
			"                nw -= comb(l, r);",
			"                r--;",
			"            }",
			"            ans[idx] = nw;",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
		"description": ""
	},
	"PrefixCombSumOnline": {
		"prefix": "PrefixCombSumOnline",
		"body": [
			"struct PrefixCombSumOnline {",
			"    int n, sq;",
			"    vector<vector<mint>> memo;",
			"",
			"    PrefixCombSumOnline() {}",
			"    PrefixCombSumOnline(int max_input) : n(max_input) {",
			"        sq = sqrt(n);",
			"        memo.resize(sq + 1);",
			"        for (int i = 0; i <= sq; i++) {",
			"            mint sum = 0;",
			"            for (int j = 0; j <= i * sq; j++) {",
			"                sum += comb(i * sq, j);",
			"                memo[i].emplace_back(sum);",
			"            }",
			"        }",
			"    }",
			"    mint solve(int n, int k, int mod = 998244353) {",
			"        // Σ_{i=0~k} nCi",
			"        int i = n / sq * sq, j = k;",
			"        mint nw;",
			"        if (j < memo[n / sq].size())",
			"            nw = memo[n / sq][j];",
			"        else",
			"            nw = pow_mod(2, i, mod);",
			"        while (i < n) {",
			"            nw *= 2;",
			"            nw -= comb(i, j);",
			"            i++;",
			"        }",
			"        return nw;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"OnlineMedian": {
		"prefix": "OnlineMedian",
		"body": [
			"template <typename T> struct OnlineMedian {",
			"    template <typename P, typename Q = vector<P>, typename R = less<P>>",
			"    struct priority_queue_ex {",
			"        priority_queue<P, Q, R> q, dq;",
			"        void push(P x) { q.push(x); }",
			"        P top() {",
			"            while (dq.size() && q.top() == dq.top()) {",
			"                q.pop();",
			"                dq.pop();",
			"            }",
			"            return q.top();",
			"        }",
			"        P pop() {",
			"            P ret = top();",
			"            q.pop();",
			"            return ret;",
			"        }",
			"        void erase(P x) { dq.push(x); }",
			"        int size() { return q.size() - dq.size(); }",
			"    };",
			"",
			"    priority_queue_ex<T> leftPQ;",
			"    priority_queue_ex<T, vector<T>, greater<T>> rightPQ;",
			"    T leftSum, rightSum;",
			"",
			"    OnlineMedian() : leftSum(0), rightSum(0) {}",
			"",
			"  private:",
			"    T getLeftMax() { return leftPQ.top(); }",
			"    T getRightMin() { return rightPQ.top(); }",
			"    void balance() {",
			"        while (leftPQ.size() < rightPQ.size()) {",
			"            T value = rightPQ.pop();",
			"            rightSum -= value;",
			"            leftSum += value;",
			"            leftPQ.push(value);",
			"        }",
			"        while (leftPQ.size() > rightPQ.size() + 1) {",
			"            T value = leftPQ.pop();",
			"            leftSum -= value;",
			"            rightSum += value;",
			"            rightPQ.push(value);",
			"        }",
			"        while (leftPQ.size() && rightPQ.size() &&",
			"               leftPQ.top() > rightPQ.top()) {",
			"            T leftValue = leftPQ.pop();",
			"            T rightValue = rightPQ.pop();",
			"            leftSum -= leftValue;",
			"            rightSum -= rightValue;",
			"            leftPQ.push(rightValue);",
			"            rightPQ.push(leftValue);",
			"            leftSum += rightValue;",
			"            rightSum += leftValue;",
			"        }",
			"    }",
			"",
			"  public:",
			"    /**",
			"     * @brief 要素追加",
			"     */",
			"    void insert(T value) {",
			"        if (leftPQ.size() == 0 || value <= getLeftMax()) {",
			"            leftPQ.push(value);",
			"            leftSum += value;",
			"        } else {",
			"            rightPQ.push(value);",
			"            rightSum += value;",
			"        }",
			"        balance();",
			"    }",
			"",
			"    /**",
			"     * @brief 要素削除",
			"     */",
			"    void erase(T value) {",
			"        if (value <= getLeftMax()) {",
			"            leftPQ.erase(value);",
			"            leftSum -= value;",
			"        } else {",
			"            rightPQ.erase(value);",
			"            rightSum -= value;",
			"        }",
			"        balance();",
			"    }",
			"",
			"    /**",
			"     * @brief Σ|a_i - median|",
			"     */",
			"    T getAbsoluteSum() {",
			"        T ret = rightSum - leftSum;",
			"        if (leftPQ.size() != rightPQ.size()) {",
			"            ret += getLeftMax();",
			"        }",
			"        return ret;",
			"    }",
			"",
			"    /**",
			"     * @brief 中央値(要素数が偶数の場合は小さい方)",
			"     */",
			"    T getMedianLeft() { return getLeftMax(); }",
			"",
			"    /**",
			"     * @brief 中央値(要素数が偶数の場合は大きい方)",
			"     */",
			"    T getMedianRight() {",
			"        if (leftPQ.size() == rightPQ.size()) {",
			"            return getRightMin();",
			"        }",
			"        return getLeftMax();",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"ExcelInt": {
		"prefix": "ExcelInt",
		"body": [
			"struct ExcelInt {",
			"    char base;",
			"",
			"    ExcelInt(char base = 'A') : base(base) {}",
			"",
			"    long long xtoi(string s) {",
			"        reverse(s.begin(), s.end());",
			"        long long ret = 0;",
			"        long long now = 1;",
			"        for (int i = 0; i < s.size(); i++) {",
			"            ret += now * (s[i] - base + 1);",
			"            now *= 26;",
			"        }",
			"        return ret;",
			"    }",
			"",
			"    string itox(long long n) {",
			"        string ret;",
			"        while (n > 0) {",
			"            n--;",
			"            ret += (char)(n % 26 + base);",
			"            n /= 26;",
			"        }",
			"        reverse(ret.begin(), ret.end());",
			"        return ret;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"slime_grundy": {
		"prefix": "slime_grundy",
		"body": [
			"ll slime_grundy(ll hp, ll d) {",
			"    /**",
			"     * 体力がhpのスライム1匹に対して2人で交互に以下の操作を行い、",
			"     * 最後にスライムを倒した人が勝ちのゲームのグランディ数",
			"     *",
			"     * 1. dダメージ与える（0以下で消滅）",
			"     * 2. 2つに分割する（合計hpは一定）",
			"     * https://mofecoder.com/contests/maximum_cup_2024/tasks/maximum_cup_2024_h",
			"     */",
			"    if (hp == 0) return 0;",
			"    if (hp <= d + d % 2) {",
			"        ll res = hp + (hp % 4 == 0 ? -1 : 0) + (hp % 4 == 3 ? 1 : 0);",
			"        return res;",
			"    }",
			"    hp -= d + (d % 2) + 1;",
			"    if (d % 2 == 0) {",
			"        ll T = d + 2;",
			"        if (hp % T == 0)",
			"            return 0;",
			"        else if (hp % T == 1)",
			"            return d + 1;",
			"        else {",
			"            hp -= 2;",
			"            ll res = (hp % T) + ((hp % T) % 4 == 2 ? 1 : 0) +",
			"                     ((hp % T) % 4 == 3 ? -1 : 0) + 1;",
			"            return res;",
			"        }",
			"    } else {",
			"        ll T = d + 1;",
			"        if (hp % T == 0)",
			"            return 0;",
			"        else {",
			"            hp--;",
			"            ll res = hp % T + ((hp % T) % 4 == 0 ? 1 : 0) +",
			"                     ((hp % T) % 4 == 1 ? -1 : 0) + 1;",
			"            return res;",
			"        }",
			"    }",
			"}",
			"",
		],
		"description": ""
	},
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	// ↓↓↓↓↓要チェック↓↓↓↓↓
	"GraphWithLowlink": {
		"prefix": "GraphWithLowlink",
		"body": [
			"struct GraphWithLowlink {",
			"    struct Edge {",
			"        int to, id;",
			"    };",
			"    struct Bridge {",
			"        int u, v;",
			"        int sizeu, sizev;",
			"    };",
			"    int n, m, k;",
			"    vector<vector<Edge>> gr;",
			"    vector<int> ord, low, visited, articulation;",
			"    vector<vector<int>> bc;",
			"",
			"    vector<int> subsize;     // 部分木サイズ",
			"    vector<int> par;         // DFS木の親",
			"    vector<int> bc_id;       // 辺のグループID",
			"    vector<Bridge> bridges;  // 橋",
			"",
			"    GraphWithLowlink(int n)",
			"        : n(n),",
			"          m(0),",
			"          k(0),",
			"          gr(n),",
			"          ord(n, -1),",
			"          low(n),",
			"          visited(n),",
			"          subsize(n),",
			"          par(n) {}",
			"    void add_edge(int u, int v) {",
			"        gr[u].push_back({v, m});",
			"        gr[v].push_back({u, m});",
			"        m++;",
			"    }",
			"    void make_subsize(int u, int p) {",
			"        par[u] = p;",
			"        visited[u] = 1;",
			"        subsize[u] = true;",
			"        for (auto [v, id] : gr[u]) {",
			"            if (v == p) continue;",
			"            if (visited[v] == 1) continue;",
			"            make_subsize(v, u);",
			"            subsize[u] += subsize[v];",
			"        }",
			"    }",
			"    void make_bridges(int u, int p, int root) {",
			"        visited[u] = 2;",
			"        ord[u] = low[u] = k++;",
			"        for (auto [v, id] : gr[u]) {",
			"            if (v == p) continue;",
			"            if (visited[v] == 2) {",
			"                low[u] = min(low[u], ord[v]);",
			"            } else {",
			"                make_bridges(v, u, root);",
			"                low[u] = min(low[u], low[v]);",
			"                if (ord[u] < low[v]) {",
			"                    bridges.push_back(",
			"                        {u, v, subsize[root] - subsize[v], subsize[v]});",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void make_jointpoints(int v, int k) {",
			"        auto add = [&](int ei, int k) {",
			"            bc[k].push_back(ei);",
			"            bc_id[ei] = k;",
			"        };",
			"        for (auto [to, id] : gr[v])",
			"            if (to != par[v]) {",
			"                if (par[to] == v) {",
			"                    int nk = k;",
			"                    if (low[to] >= ord[v]) {",
			"                        nk = bc.size();",
			"                        bc.emplace_back();",
			"                    }",
			"                    add(id, nk);",
			"                    make_jointpoints(to, nk);",
			"                } else if (ord[to] < ord[v]) {",
			"                    add(id, k);",
			"                }",
			"            }",
			"    }",
			"    void build() {",
			"        bc_id.resize(m, -1);",
			"        for (int i = 0; i < n; i++) {",
			"            if (!visited[i]) {",
			"                make_subsize(i, -1);",
			"                make_bridges(i, -1, i);",
			"                make_jointpoints(i, -1);",
			"            }",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"SheetOverlapCulculator": {
		"prefix": "SheetOverlapCulculator",
		"body": [
			"template <typename T> struct SheetOverlapCulculator {",
			"    int n;",
			"    vector<ll> xlv, xrv, ylv, yrv;",
			"    SheetOverlapCulculator() {}",
			"    void add_sheet(ll xl, ll xr, ll yl, ll yr) {",
			"        // 半開区間 [xl, xr) × [yl, yr)",
			"        n++;",
			"        xlv.push_back(xl);",
			"        xrv.push_back(xr);",
			"        ylv.push_back(yl);",
			"        yrv.push_back(yr);",
			"    }",
			"    void add_point(ll i, ll j) { add_sheet(i, i + 1, j, j + 1); }",
			"    vector<T> solve() {",
			"        // シートが i 枚重なっている部分の面積を計算",
			"        vector<ll> X1, Y1, X2, Y2, X, Y;",
			"        for (int i = 0; i < n; ++i) {",
			"            ll x1 = xlv[i], y1 = ylv[i];",
			"            X1.push_back(x1);",
			"            Y1.push_back(y1);",
			"            X.push_back(x1);",
			"            Y.push_back(y1);",
			"            ll x2 = xrv[i], y2 = yrv[i];",
			"            X2.push_back(x2);",
			"            Y2.push_back(y2);",
			"            X.push_back(x2);",
			"            Y.push_back(y2);",
			"        }",
			"        sort(X.begin(), X.end());",
			"        X.erase(unique(X.begin(), X.end()), X.end());",
			"        sort(Y.begin(), Y.end());",
			"        Y.erase(unique(Y.begin(), Y.end()), Y.end());",
			"        int w = X.size(), h = Y.size();",
			"        vector<vector<ll>> dp(w, vector<ll>(h));",
			"        for (int i = 0; i < n; ++i) {",
			"            int x1 = lower_bound(X.begin(), X.end(), X1[i]) - X.begin();",
			"            int x2 = lower_bound(X.begin(), X.end(), X2[i]) - X.begin();",
			"            int y1 = lower_bound(Y.begin(), Y.end(), Y1[i]) - Y.begin();",
			"            int y2 = lower_bound(Y.begin(), Y.end(), Y2[i]) - Y.begin();",
			"            dp[x1][y1]++;",
			"            dp[x2][y1]--;",
			"            dp[x1][y2]--;",
			"            dp[x2][y2]++;",
			"        }",
			"        for (int i = 0; i < w; ++i) {",
			"            for (int j = 1; j < h; ++j) {",
			"                dp[i][j] += dp[i][j - 1];",
			"            }",
			"        }",
			"        for (int i = 1; i < w; ++i) {",
			"            for (int j = 0; j < h; ++j) {",
			"                dp[i][j] += dp[i - 1][j];",
			"            }",
			"        }",
			"        vector<T> area(n + 1);",
			"        for (int i = 0; i < w - 1; ++i) {",
			"            for (int j = 0; j < h - 1; ++j) {",
			"                area[dp[i][j]] += (X[i + 1] - X[i]) * ((Y[j + 1] - Y[j]));",
			"            }",
			"        }",
			"        return area;",
			"    }",
			"};",
			"",
		],
		"description": "長方形の重なりの個数ごとに面積を計算"
	},
	"Affine": {
		"prefix": "Affine",
		"body": [
			"template <class T>",
			"struct Affine {",
			"    int n;",
			"    vector<MatrixFast<T>> ms;",
			"    Affine() { init(); }",
			"",
			"    void init() {",
			"        n = 0;",
			"        ms = vector<MatrixFast<T>>(1, MatrixFast<T>::I(3));",
			"    }",
			"",
			"    void rotate90() {",
			"        MatrixFast<T> m(3, 3);",
			"        m[0][1] = -1;",
			"        m[1][0] = 1;",
			"        m[2][2] = 1;",
			"        ms.emplace_back(m * ms[n]);",
			"        n++;",
			"    }",
			"",
			"    void rotate180() {",
			"        MatrixFast<T> m(3, 3);",
			"        m[0][0] = -1;",
			"        m[1][1] = -1;",
			"        m[2][2] = 1;",
			"        ms.emplace_back(m * ms[n]);",
			"        n++;",
			"    }",
			"",
			"    void rotate270() {",
			"        MatrixFast<T> m(3, 3);",
			"        m[0][1] = 1;",
			"        m[1][0] = -1;",
			"        m[2][2] = 1;",
			"        ms.emplace_back(m * ms[n]);",
			"        n++;",
			"    }",
			"",
			"    void rotate(T theta) {",
			"        MatrixFast<T> m(3, 3);",
			"        m[0][0] = cos(theta);",
			"        m[0][1] = -sin(theta);",
			"        m[1][0] = sin(theta);",
			"        m[1][1] = cos(theta);",
			"        m[2][2] = 1;",
			"        ms.emplace_back(m * ms[n]);",
			"        n++;",
			"    }",
			"",
			"    void mirror_x(T x = 0) {",
			"        MatrixFast<T> m(3, 3);",
			"        m[0][0] = -1;",
			"        m[1][1] = 1;",
			"        m[2][2] = 1;",
			"        m[0][2] = 2 * x;",
			"        ms.emplace_back(m * ms[n]);",
			"        n++;",
			"    }",
			"",
			"    void mirror_y(T y = 0) {",
			"        MatrixFast<T> m(3, 3);",
			"        m[0][0] = 1;",
			"        m[1][1] = -1;",
			"        m[2][2] = 1;",
			"        m[1][2] = 2 * y;",
			"        ms.emplace_back(m * ms[n]);",
			"        n++;",
			"    }",
			"",
			"    pair<T, T> f(T x, T y, int i = -1) {",
			"        MatrixFast<T> m = (i == -1 ? ms[n] : ms[i]);",
			"        return {x * m[0][0] + y * m[0][1] + m[0][2],",
			"                x * m[1][0] + y * m[1][1] + m[1][2]};",
			"    }",
			"};",
			"",
		],
		"description": "アフィン変換"
	},
	"CHT": {
		"prefix": "CHT",
		"body": [
			"template <typename T>",
			"class CHT {",
			"   private:",
			"    struct node {",
			"        node *left, *right;",
			"        static const T inf = numeric_limits<T>::max();",
			"        T a, b, l, r;",
			"        node(const T _a, const T _b, const T _l, const T _r)",
			"            : left(nullptr), right(nullptr), a(_a), b(_b), l(_l), r(_r) {}",
			"        T f(const T x) const { return (l <= x && x < r) ? (a * x + b) : inf; }",
			"        T tf(const T x) const { return a * x + b; }",
			"        bool isLine(const T _l, const T _r) const {",
			"            return (l == _l) && (r == _r);",
			"        }",
			"    };",
			"    static void swap(node *x, node *y) {",
			"        std::swap(x->a, y->a), std::swap(x->b, y->b), std::swap(x->l, y->l),",
			"            std::swap(x->r, y->r);",
			"    }",
			"    void _add_line(node *cur, node *nw, T l, T r) {",
			"        while (true) {",
			"            if (nw->f(l) < cur->f(l)) swap(cur, nw);",
			"            if (cur->f(r - 1) <= nw->f(r - 1)) break;",
			"            const T mid = (l + r) / 2;",
			"            if (cur->f(mid) <= nw->f(mid)) {",
			"                if (!cur->right) {",
			"                    cur->right = new node(*nw);",
			"                    break;",
			"                } else {",
			"                    cur = cur->right, l = mid;",
			"                }",
			"            } else {",
			"                swap(cur, nw);",
			"                if (!cur->left) {",
			"                    cur->left = new node(*nw);",
			"                    break;",
			"                } else {",
			"                    cur = cur->left, r = mid;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void _add_segment(node *cur, node *nw, T l, T r) {",
			"        while (true) {",
			"            const T mid = (l + r) / 2;",
			"            if (cur->f(nw->l) <= nw->tf(nw->l) &&",
			"                cur->f(nw->r - 1) <= nw->tf(nw->r - 1)) {",
			"                break;",
			"            }",
			"            if (cur->tf(cur->l) >= nw->f(cur->l) &&",
			"                cur->tf(cur->r - 1) >= nw->f(cur->r - 1)) {",
			"                swap(cur, nw);",
			"                break;",
			"            }",
			"            if (cur->isLine(l, r) && nw->isLine(l, r)) {",
			"                if (nw->tf(l) < cur->tf(l)) swap(cur, nw);",
			"                if (cur->tf(mid) <= nw->tf(mid)) {",
			"                    if (!cur->right) {",
			"                        cur->right = new node(nw->a, nw->b, mid, r);",
			"                        break;",
			"                    } else {",
			"                        cur = cur->right, l = mid, nw->l = mid;",
			"                    }",
			"                } else {",
			"                    swap(cur, nw);",
			"                    if (!cur->left) {",
			"                        cur->left = new node(nw->a, nw->b, l, mid);",
			"                        break;",
			"                    } else {",
			"                        cur = cur->left, r = mid, nw->r = mid;",
			"                    }",
			"                }",
			"                continue;",
			"            }",
			"            if (nw->isLine(l, r)) swap(cur, nw);",
			"            if (nw->r <= mid) {",
			"                if (!cur->left) {",
			"                    cur->left = new node(*nw);",
			"                    break;",
			"                } else {",
			"                    cur = cur->left, r = mid;",
			"                }",
			"            } else if (mid <= nw->l) {",
			"                if (!cur->right) {",
			"                    cur->right = new node(*nw);",
			"                    break;",
			"                } else {",
			"                    cur = cur->right, l = mid;",
			"                }",
			"            } else {",
			"                node _nw(nw->a, nw->b, mid, nw->r);",
			"                nw->r = mid;",
			"                if (!cur->left) {",
			"                    cur->left = new node(*nw);",
			"                } else {",
			"                    _add_segment(cur->left, nw, l, mid);",
			"                }",
			"                if (!cur->right) {",
			"                    cur->right = new node(_nw);",
			"                } else {",
			"                    _add_segment(cur->right, &_nw, mid, r);",
			"                }",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    T query(node *cur, const T k, T l, T r) const {",
			"        T ans = numeric_limits<T>::max();",
			"        while (cur) {",
			"            ans = min(ans, cur->f(k));",
			"            const T mid = (l + r) / 2;",
			"            if (k < mid) {",
			"                cur = cur->left, r = mid;",
			"            } else {",
			"                cur = cur->right, l = mid;",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"    void clear(node *cur) {",
			"        if (cur->left) clear(cur->left);",
			"        if (cur->right) clear(cur->right);",
			"        delete cur;",
			"    }",
			"    const T lpos, rpos;",
			"    node *root;",
			"",
			"   public:",
			"    CHT(const T _lpos, const T _rpos)",
			"        : lpos(_lpos),",
			"          rpos(_rpos),",
			"          root(new node(0, numeric_limits<T>::max(), lpos, rpos)) {",
			"        assert(lpos < rpos);",
			"    }",
			"    // ~CHT(){ clear(root); }",
			"    // f(x) = a * x + b を挿入",
			"    void add_line(const T a, const T b) {",
			"        node nw(a, b, lpos, rpos);",
			"        return _add_line(root, &nw, lpos, rpos);",
			"    }",
			"    // f(x) = a * x + b (x ∈ [l, r)) を挿入",
			"    void add_segment(const T a, const T b, const T l, const T r) {",
			"        assert(l < r);",
			"        node nw(a, b, l, r);",
			"        return _add_segment(root, &nw, lpos, rpos);",
			"    }",
			"    // x = k での最小値",
			"    T query(const T k) const { return query(root, k, lpos, rpos); }",
			"};",
		],
		"description": ""
	},
	"Knapsack": {
		"prefix": "Knapsack",
		"body": [
			"struct Knapsack {",
			"    ll N, ans;",
			"    vector<pair<ll, ll>> goods; // (価値，重さ)",
			"    vector<vector<ll>> dp;",
			"    vector<int> pick;",
			"    ll sum_v; // 品物に関する最大値",
			"",
			"    Knapsack() { init(); }",
			"",
			"    void init() {",
			"        N = 0;",
			"        sum_v = 0;",
			"        ans = 0;",
			"    }",
			"",
			"    ll inf() { return 2e18; }",
			"",
			"    void add_goods(ll v, ll w) {",
			"        N++;",
			"        goods.push_back(make_pair(v, w));",
			"        sum_v += v;",
			"    }",
			"",
			"    /**",
			"     * O(NW)",
			"     */",
			"    ll solve(ll W) {",
			"        vector<ll> dp(W + 1, 0);",
			"        for (ll i = 0; i < N; i++) {",
			"            for (ll w = W; w >= goods[i].second; w--) {",
			"                dp[w] = max(dp[w], dp[w - goods[i].second] + goods[i].first);",
			"            }",
			"        }",
			"        return dp[W];",
			"    }",
			"",
			"    /**",
			"     * O(NW)",
			"     */",
			"    ll solve_small_W(ll W, bool prev = false) {",
			"        dp.assign(N + 1, vector<ll>(W + 1, 0));",
			"        rep(i, 0, N) {",
			"            rep(j, 0, W + 1) {",
			"                dp[i + 1][j] = dp[i][j];",
			"                if (j >= goods[i].second) {",
			"                    dp[i + 1][j] =",
			"                        max(dp[i + 1][j],",
			"                            dp[i][j - goods[i].second] + goods[i].first);",
			"                }",
			"            }",
			"        }",
			"        if (prev) {",
			"            ll j = W;",
			"            for (ll i = N; i > 0; i--) {",
			"                if (dp[i][j] != dp[i - 1][j]) {",
			"                    pick.push_back(i - 1);",
			"                    j -= goods[i - 1].second;",
			"                }",
			"            }",
			"        }",
			"        return dp[N][W];",
			"    }",
			"",
			"    /**",
			"     * O(N * SUM_v)",
			"     */",
			"    ll solve_small_V(ll W, bool prev = false) {",
			"        dp.assign(N + 1, vector<ll>(sum_v + 1, inf()));",
			"        dp[0][0] = 0;",
			"        rep(i, 0, N) {",
			"            rep(j, 0, sum_v + 1) {",
			"                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j]);",
			"                if (j >= goods[i].first) {",
			"                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][j - goods[i].first] +",
			"                                                         goods[i].second);",
			"                }",
			"            }",
			"        }",
			"        ll res = 0;",
			"        rep(i, 0, sum_v + 1) {",
			"            if (dp[N][i] <= W)",
			"                res = i;",
			"        }",
			"        if (prev) {",
			"            ll j = res;",
			"            for (ll i = N; i > 0; i--) {",
			"                if (dp[i][j] ==",
			"                    dp[i - 1][j - goods[i - 1].first] + goods[i - 1].second) {",
			"                    pick.push_back(i - 1);",
			"                    j -= goods[i - 1].first;",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"",
			"    /**",
			"     * O(2^(N/2) * N)",
			"     */",
			"    ll solve_small_N(ll W, bool prev = false) {",
			"        if (prev) {",
			"            // 普通の解法のpairの代わりにtupleをつかい、3番目に選んだ品物の1LL<<indexで管理する",
			"            // 最後まではpickmaskに保管をし、最後にpickに変換する",
			"            vector<tuple<ll, ll, ll>> A, B;",
			"            rep(i, 0, N / 2) A.push_back(",
			"                make_tuple(goods[i].first, goods[i].second, 1LL << i));",
			"            rep(i, N / 2, N) B.push_back(",
			"                make_tuple(goods[i].first, goods[i].second, 1LL << i));",
			"            vector<tuple<ll, ll, ll>> a, b;",
			"            rep(i, 0, 1 << A.size()) {",
			"                ll v = 0, w = 0, mask = 0;",
			"                rep(j, 0, A.size()) {",
			"                    if (i >> j & 1) {",
			"                        v += get<0>(A[j]);",
			"                        w += get<1>(A[j]);",
			"                        mask |= get<2>(A[j]);",
			"                    }",
			"                }",
			"                a.push_back(make_tuple(w, v, mask));",
			"            }",
			"            rep(i, 0, 1 << B.size()) {",
			"                ll v = 0, w = 0, mask = 0;",
			"                rep(j, 0, B.size()) {",
			"                    if (i >> j & 1) {",
			"                        v += get<0>(B[j]);",
			"                        w += get<1>(B[j]);",
			"                        mask |= get<2>(B[j]);",
			"                    }",
			"                }",
			"                b.push_back(make_tuple(w, v, mask));",
			"            }",
			"            sort(b.begin(), b.end());",
			"            rep(i, 1, b.size()) {",
			"                if (get<1>(b[i]) < get<1>(b[i - 1])) {",
			"                    get<1>(b[i]) = get<1>(b[i - 1]);",
			"                    get<2>(b[i]) = get<2>(b[i - 1]);",
			"                }",
			"            }",
			"            ll res = 0, pickmask = 0;",
			"            rep(i, 0, a.size()) {",
			"                if (get<0>(a[i]) <= W) {",
			"                    ll ok = -1, ng = b.size();",
			"                    while (ng - ok > 1) {",
			"                        ll mid = (ok + ng) / 2;",
			"                        if (get<0>(a[i]) + get<0>(b[mid]) <= W) {",
			"                            ok = mid;",
			"                        } else {",
			"                            ng = mid;",
			"                        }",
			"                    }",
			"                    if (get<1>(a[i]) + get<1>(b[ok]) > res) {",
			"                        res = get<1>(a[i]) + get<1>(b[ok]);",
			"                        pickmask = get<2>(a[i]) | get<2>(b[ok]);",
			"                    }",
			"                }",
			"            }",
			"            rep(i, 0, N) {",
			"                if (pickmask >> i & 1)",
			"                    pick.push_back(i);",
			"            }",
			"            return res;",
			"        } else {",
			"            vector<pair<ll, ll>> A, B;",
			"            rep(i, 0, N / 2) A.push_back(goods[i]);",
			"            rep(i, N / 2, N) B.push_back(goods[i]);",
			"            vector<pair<ll, ll>> a, b;",
			"            rep(i, 0, 1 << A.size()) {",
			"                ll v = 0, w = 0;",
			"                rep(j, 0, A.size()) {",
			"                    if (i >> j & 1) {",
			"                        v += A[j].first;",
			"                        w += A[j].second;",
			"                    }",
			"                }",
			"                a.push_back(make_pair(w, v));",
			"            }",
			"            rep(i, 0, 1 << B.size()) {",
			"                ll v = 0, w = 0;",
			"                rep(j, 0, B.size()) {",
			"                    if (i >> j & 1) {",
			"                        v += B[j].first;",
			"                        w += B[j].second;",
			"                    }",
			"                }",
			"                b.push_back(make_pair(w, v));",
			"            }",
			"            sort(b.begin(), b.end());",
			"            rep(i, 1, b.size()) b[i].second = max(b[i].second, b[i - 1].second);",
			"            ll res = 0;",
			"            rep(i, 0, a.size()) {",
			"                if (a[i].first <= W) {",
			"                    ll ok = -1, ng = b.size();",
			"                    while (ng - ok > 1) {",
			"                        ll mid = (ok + ng) / 2;",
			"                        if (a[i].first + b[mid].first <= W) {",
			"                            ok = mid;",
			"                        } else {",
			"                            ng = mid;",
			"                        }",
			"                    }",
			"                    res = max(res, a[i].second + b[ok].second);",
			"                }",
			"            }",
			"            return res;",
			"        }",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"MinimumXorPair": {
		"prefix": "MinimumXorPair",
		"body": [
			"template <class T> struct MinimumXorPair {",
			"    multiset<T> contents, vals;",
			"",
			"    MinimumXorPair() {}",
			"",
			"    T op(T a, T b) { return a ^ b; }",
			"    T impossible() { return -1; }",
			"",
			"    void insert(T x) {",
			"        auto it = contents.lower_bound(x);",
			"        T l = impossible(), r = impossible();",
			"        if (it != contents.end()) {",
			"            vals.insert(op(*it, x));",
			"            l = *it;",
			"        }",
			"        if (it != contents.begin()) {",
			"            it--;",
			"            vals.insert(op(*it, x));",
			"            r = *it;",
			"        }",
			"        if (l != impossible() && r != impossible()) {",
			"            vals.erase(vals.find(op(l, r)));",
			"        }",
			"        contents.insert(x);",
			"    }",
			"    void erase(T x) {",
			"        contents.erase(contents.find(x));",
			"        T l = impossible(), r = impossible();",
			"        auto it = contents.lower_bound(x);",
			"        if (it != contents.end()) {",
			"            vals.erase(vals.find(op(*it, x)));",
			"            l = *it;",
			"        }",
			"        if (it != contents.begin()) {",
			"            it--;",
			"            vals.erase(vals.find(op(*it, x)));",
			"            r = *it;",
			"        }",
			"        if (l != impossible() && r != impossible()) {",
			"            vals.insert(op(l, r));",
			"        }",
			"    }",
			"    T get_min() {",
			"        if (!vals.size())",
			"            return impossible();",
			"        return *vals.begin();",
			"    }",
			"    T get_max() {",
			"        if (!vals.size())",
			"            return impossible();",
			"        return *vals.rbegin();",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"MergeSortTree": {
		"prefix": "MergeSortTree",
		"body": [
			"template <typename T = ll>",
			"struct MergeSortTree {",
			"    int n;",
			"    vector<vector<T>> a, sm;",
			"    bool builded = false;",
			"    MergeSortTree(int mx) { init(mx); }",
			"    MergeSortTree(vector<T>& v) {",
			"        init((int)v.size());",
			"        rep(i, 0, v.size()) set(i, v[i]);",
			"    }",
			"    void init(int mx) {",
			"        n = 1;",
			"        while (n < mx) n <<= 1;",
			"        a.resize(2 * n);",
			"        sm.resize(2 * n, vector<T>(1));",
			"    }",
			"    void set(int i, T x) {",
			"        a[n + i] = {x};",
			"        sm[n + i] = {0, x};",
			"    }",
			"    void build() {",
			"        builded = true;",
			"        for (int i = n - 1; i >= 1; i--) {",
			"            int l = i << 1, r = l | 1;",
			"            mergesort(l, r, i);",
			"        }",
			"    }",
			"    void mergesort(int l, int r, int to) {",
			"        vector<T> tmp;",
			"        rep(i, 0, a[l].size()) tmp.push_back(a[l][i]);",
			"        rep(i, 0, a[r].size()) tmp.push_back(a[r][i]);",
			"        sort(tmp.begin(), tmp.end());",
			"        sm[to].resize(tmp.size() + 1);",
			"        rep(i, 0, tmp.size()) sm[to][i + 1] = sm[to][i] + tmp[i];",
			"        a[to] = tmp;",
			"    }",
			"    T get(int i, T x) {",
			"        if (!builded) build();",
			"        T ind = upper_bound(a[i].begin(), a[i].end(), x) - a[i].begin();",
			"        return sm[i][ind];",
			"    }",
			"    T culc(deque<T>& tmp) {",
			"        T ret = 0;",
			"        rep(i, 0, tmp.size()) ret += tmp[i];",
			"        return ret;",
			"    }",
			"    T query(int l, int r, T x) {",
			"        l += n, r += n;",
			"        deque<T> ltmp, rtmp;",
			"        while (l < r) {",
			"            if (l & 1) ltmp.push_back(get(l++, x));",
			"            if (r & 1) rtmp.push_front(get(--r, x));",
			"            l >>= 1;",
			"            r >>= 1;",
			"        }",
			"        while (rtmp.size()) ltmp.push_back(rtmp.front()), rtmp.pop_front();",
			"        return culc(ltmp);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"AllPairOperationSum": {
		"prefix": "AllPairOperationSum",
		"body": [
			"template <class T, class S = T>",
			"struct AllPairOperationSum {",
			"    // https://shakayami.hatenablog.com/entry/2021/01/01/044946",
			"    // Σ op(a[i], a[j]) (i < j)",
			"    ll n;",
			"    vector<T> a;",
			"    AllPairOperationSum() {}",
			"    AllPairOperationSum(vector<T> a) : a(a), n(a.size()) {}",
			"    S add() {",
			"        // A + B",
			"        // O(N)",
			"        S ret = 0;",
			"        rep(i, 0, n) ret += a[i];",
			"        ret *= (n - 1);",
			"        return ret;",
			"    }",
			"    S sub() {",
			"        // A - B",
			"        // O(N)",
			"        S ret = 0;",
			"        rep(i, 0, n) ret += (S)(n - 1 - i * 2) * a[i];",
			"        return ret;",
			"    }",
			"    S mul() {",
			"        // A * B",
			"        // O(N)",
			"        S ret = 0;",
			"        vector<S> s(n);",
			"        s[0] = a[0];",
			"        rep(i, 1, n) {",
			"            s[i] = s[i - 1] + a[i];",
			"            ret += s[i - 1] * a[i];",
			"        }",
			"        return ret;",
			"    }",
			"    S div() {",
			"        // A / B (有理数mod)",
			"        // O(N log maxA)",
			"        S ret = 0;",
			"        vector<S> invs(n);",
			"        reverse(a.begin(), a.end());",
			"        invs[0] = (S)1 / a[0];",
			"        rep(i, 1, n) invs[i] = invs[i - 1] + (S)1 / a[i];",
			"        rep(i, 1, n) ret += invs[i - 1] * a[i];",
			"        reverse(a.begin(), a.end());",
			"        return ret;",
			"    }",
			"    T floor() {",
			"        // floor(A / B)",
			"        // O(N √maxA log maxA)",
			"        T maxa = *max_element(a.begin(), a.end());",
			"        T sqrtmaxa = sqrt(maxa);",
			"        vector<T> v(sqrtmaxa, 0);",
			"        fenwick_tree<T> ft(maxa + 1);",
			"        T ret = 0;",
			"        rep(i, 0, n) {",
			"            if (a[i] < sqrtmaxa) {",
			"                ret += v[a[i]];",
			"            } else {",
			"                for (T k = 0; k < maxa + 1; k += a[i]) {",
			"                    ret += (k / a[i]) * ft.sum(k, std::min(k + a[i], maxa + 1));",
			"                }",
			"            }",
			"            ft.add(a[i], 1);",
			"            for (T j = 1; j < sqrtmaxa; j++) {",
			"                v[j] += a[i] / j;",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"    T mod() {",
			"        // A % B",
			"        // O(N √maxA log maxA)",
			"        T maxa = *max_element(a.begin(), a.end());",
			"        T sqrtmaxa = sqrt(maxa);",
			"        vector<T> v(sqrtmaxa, 0);",
			"        fenwick_tree<T> ft(maxa + 1);",
			"        T ret = 0;",
			"        rep(i, 0, n) {",
			"            if (a[i] < sqrtmaxa) {",
			"                ret += v[a[i]] * a[i];",
			"            } else {",
			"                for (T k = 0; k < maxa + 1; k += a[i]) {",
			"                    ret += (k / a[i]) *",
			"                           ft.sum(k, std::min(k + a[i], maxa + 1)) * a[i];",
			"                }",
			"            }",
			"            ft.add(a[i], 1);",
			"            for (T j = 1; j < sqrtmaxa; j++) {",
			"                v[j] += a[i] / j;",
			"            }",
			"        }",
			"        ret *= -1;",
			"        rep(i, 0, n) ret += (n - 1 - i) * a[i];",
			"        return ret;",
			"    }",
			"    S error_sq() {",
			"        // (A - B)^2",
			"        // O(N)",
			"        S ret = 0;",
			"        rep(i, 0, n) ret += (S)a[i] * a[i];",
			"        ret *= (n - 1);",
			"        ret += mul() * (-2);",
			"        return ret;",
			"    }",
			"    S max() {",
			"        // max(A, B)",
			"        // O(N)",
			"        S ret = 0;",
			"        vector<T> b = a;",
			"        sort(b.begin(), b.end());",
			"        rep(i, 0, n) ret += (S)i * b[i];",
			"        return ret;",
			"    }",
			"    S min() {",
			"        // min(A, B)",
			"        // O(N)",
			"        S ret = 0;",
			"        vector<T> b = a;",
			"        sort(b.rbegin(), b.rend());",
			"        rep(i, 0, n) ret += (S)i * b[i];",
			"        return ret;",
			"    }",
			"    S error() {",
			"        // |A - B|",
			"        // O(N)",
			"        S ret = 0;",
			"        vector<T> b = a;",
			"        sort(b.rbegin(), b.rend());",
			"        rep(i, 0, n) ret += (S)(n - 1 - i * 2) * b[i];",
			"        return ret;",
			"    }",
			"    S xor_() {",
			"        // A xor B",
			"        // O(N log maxA)",
			"        T mx = *max_element(a.begin(), a.end());",
			"        S ret = 0;",
			"        int base = 0;",
			"        while (mx >> base) {",
			"            vector<ll> cnt(2);",
			"            rep(i, 0, n) cnt[(a[i] >> base) & 1]++;",
			"            ret += (S)(1LL << base) * (cnt[0] * cnt[1]);",
			"            base++;",
			"        }",
			"        return ret;",
			"    }",
			"    S and_() {",
			"        // A & B",
			"        // O(N log maxA)",
			"        T mx = *max_element(a.begin(), a.end());",
			"        S ret = 0;",
			"        int base = 0;",
			"        while (mx >> base) {",
			"            vector<ll> cnt(2);",
			"            rep(i, 0, n) cnt[(a[i] >> base) & 1]++;",
			"            ret += (S)(1LL << base) * (cnt[1] * (cnt[1] - 1) / 2);",
			"            base++;",
			"        }",
			"        return ret;",
			"    }",
			"    S or_() {",
			"        // A | B",
			"        // O(N log maxA)",
			"        T mx = *max_element(a.begin(), a.end());",
			"        S ret = 0;",
			"        int base = 0;",
			"        while (mx >> base) {",
			"            vector<ll> cnt(2);",
			"            rep(i, 0, n) cnt[(a[i] >> base) & 1]++;",
			"            ret += (S)(1LL << base) *",
			"                   (n * (n - 1) / 2 - cnt[0] * (cnt[0] - 1) / 2);",
			"            base++;",
			"        }",
			"        return ret;",
			"    }",
			"    S lcm() {",
			"        // lcm(A, B)",
			"        // O(maxA log maxA)",
			"        T m = *max_element(a.begin(), a.end());",
			"        vector<S> w(m + 1);",
			"        rep(i, 1, m + 1) {",
			"            w[i] += (S)1 / i;",
			"            int di = i + i;",
			"            while (di <= m) {",
			"                w[di] -= w[i];",
			"                di += i;",
			"            }",
			"        }",
			"        vector<ll> b(m + 1);",
			"        rep(i, 0, n) b[a[i]]++;",
			"        S ret = 0;",
			"        rep(i, 1, m + 1) {",
			"            ll di = i;",
			"            S sm = 0;",
			"            while (di <= m) {",
			"                sm += (S)b[di] * di;",
			"                di += i;",
			"            }",
			"            ret += (S)w[i] * sm * sm;",
			"        }",
			"        rep(i, 0, n) ret -= a[i];",
			"        ret /= 2;",
			"        return ret;",
			"    }",
			"    S gcd() {",
			"        // gcd(A, B)",
			"        // O(maxA log maxA)",
			"        T m = *max_element(a.begin(), a.end());",
			"        vector<S> w(m + 1);",
			"        rep(i, 1, m + 1) {",
			"            w[i] += i;",
			"            int di = i + i;",
			"            while (di <= m) {",
			"                w[di] -= w[i];",
			"                di += i;",
			"            }",
			"        }",
			"        vector<ll> b(m + 1);",
			"        rep(i, 0, n) b[a[i]]++;",
			"        S ret = 0;",
			"        rep(i, 1, m + 1) {",
			"            ll di = i;",
			"            S sm = 0;",
			"            while (di <= m) {",
			"                sm += b[di];",
			"                di += i;",
			"            }",
			"            ret += (S)w[i] * sm * sm;",
			"        }",
			"        rep(i, 0, n) ret -= a[i];",
			"        ret /= 2;",
			"        return ret;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"RangeLinearAddRangeMin": {
		"prefix": "RangeLinearAddRangeMin",
		"body": [
			"template <typename T>",
			"struct RangeLinearAddRangeMin {",
			"    // 未varify",
			"    // https://judge.yosupo.jp/submission/195497",
			"   private:",
			"    using Int = T;",
			"    using CInt = T;",
			"    using Point = std::array<Int, 2>;",
			"    struct Lazy {",
			"        Int a, b;",
			"        constexpr Lazy() : Lazy(0, 0){};",
			"        constexpr Lazy(Int a, Int b) : a(a), b(b) {}",
			"        constexpr Lazy& operator+=(const Lazy& x) {",
			"            return a += x.a, b += x.b, *this;",
			"        }",
			"        constexpr Lazy operator+(const Lazy& x) const {",
			"            Lazy y{*this};",
			"            y += x;",
			"            return y;",
			"        }",
			"        constexpr Int eval(const Int x) const { return a * x + b; }",
			"    };",
			"",
			"   public:",
			"    RangeLinearAddRangeMin() : RangeLinearAddRangeMin(0){};",
			"    RangeLinearAddRangeMin(std::vector<T> a)",
			"        : _n(a.size()),",
			"          _log(_ceil_log_2(_n)),",
			"          _siz(1 << _log),",
			"          _bridge(2 * _siz),",
			"          _laz(2 * _siz),",
			"          _min_x(2 * _siz) {",
			"        a.resize(_siz, Int{0});",
			"",
			"        for (int i = 0; i < _siz; ++i) {",
			"            _bridge[_siz + i] = {Point{(T)i, a[i]}, Point{(T)i, a[i]}};",
			"            _laz[_siz + i] = {0, a[i]};",
			"            _min_x[_siz + i] = i;",
			"        }",
			"        for (int k = _siz - 1; k; --k) {",
			"            _min_x[k] = _min_x[2 * k];",
			"            _update_bridge(k);",
			"        }",
			"    }",
			"    RangeLinearAddRangeMin(int n, Int fill_value = 0)",
			"        : RangeLinearAddRangeMin(std::vector<Int>(n, fill_value)) {}",
			"",
			"    // Update as X[i] <- X[i] + a * i + b for all i in [l,r)",
			"    void linear_add(int l, int r, Int a, Int b) {",
			"        assert(0 <= l and l <= r and r <= _n);",
			"        _linear_add(1, 0, _siz, l, r, {a, b});",
			"    }",
			"    // Get min_{i in [l,r)} X[i]",
			"    Int min(int l, int r) const {",
			"        assert(0 <= l and l < r and r <= _n);",
			"        return _min(1, 0, _siz, l, r, {0, 0});",
			"    }",
			"",
			"   private:",
			"    int _n, _log, _siz;",
			"    std::vector<std::pair<Point, Point>> _bridge;",
			"    std::vector<Lazy> _laz;",
			"    std::vector<int> _min_x;",
			"",
			"    static constexpr int _ceil_log_2(int n) {",
			"        int l = 0;",
			"        while ((1 << l) < n) ++l;",
			"        return l;",
			"    }",
			"    // clockwise",
			"    static constexpr bool _is_cw(const Point& a, const Point& b,",
			"                                 const Point& c) {",
			"        Int x0 = b[0] - a[0], y0 = b[1] - a[1];",
			"        Int x1 = c[0] - b[0], y1 = c[1] - b[1];",
			"        return CInt(x0) * y1 < CInt(x1) * y0;",
			"    }",
			"",
			"    void _update_bridge(int k) {",
			"        int l = k, r = k;",
			"        Lazy acc_l, acc_r;",
			"        const auto down_l = [&](bool i) { acc_l += _laz[l], l = 2 * l + i; };",
			"        const auto down_r = [&](bool i) { acc_r += _laz[r], r = 2 * r + i; };",
			"        for (down_l(0), down_r(1); l < _siz or r < _siz;) {",
			"            auto [p_l, q_l] = _bridge[l];",
			"            auto [p_r, q_r] = _bridge[r];",
			"            p_l[1] += acc_l.eval(p_l[0]), q_l[1] += acc_l.eval(q_l[0]);",
			"            p_r[1] += acc_r.eval(p_r[0]), q_r[1] += acc_r.eval(q_r[0]);",
			"            if (l < _siz and _is_cw(p_l, q_l, p_r)) {",
			"                down_l(0);",
			"                continue;",
			"            }",
			"            if (r < _siz and _is_cw(q_l, p_r, q_r)) {",
			"                down_r(1);",
			"                continue;",
			"            }",
			"            if (r >= _siz) {",
			"                down_l(1);",
			"                continue;",
			"            }",
			"            if (l >= _siz) {",
			"                down_r(0);",
			"                continue;",
			"            }",
			"            const Int abx = q_l[0] - p_l[0], aby = q_l[1] - p_l[1];",
			"            const Int cdx = q_r[0] - p_r[0], cdy = q_r[1] - p_r[1];",
			"            const CInt xy = CInt(abx) * cdy, yx = CInt(aby) * cdx,",
			"                       xx = CInt(abx) * cdx;",
			"            CInt den = yx - xy;",
			"            CInt num = p_l[0] * yx - p_r[0] * xy - (p_l[1] - p_r[1]) * xx;",
			"            if (den < 0) den = -den, num = -num;",
			"            if (den * _min_x[r] <= num) {",
			"                down_r(0);",
			"            } else {",
			"                down_l(1);",
			"            }",
			"        }",
			"        Point p = _bridge[l].first;",
			"        Point q = _bridge[r].first;",
			"        _bridge[k] = {Point{p[0], p[1] + acc_l.eval(p[0])},",
			"                      Point{q[0], q[1] + acc_r.eval(q[0])}};",
			"    }",
			"",
			"    void _linear_add(int k, int tl, int tr, int l, int r, const Lazy& f) {",
			"        if (tl >= r or tr <= l) return;",
			"        if (l <= tl and tr <= r) {",
			"            _laz[k] += f;",
			"            auto& [p, q] = _bridge[k];",
			"            p[1] += f.eval(p[0]);",
			"            q[1] += f.eval(q[0]);",
			"            return;",
			"        }",
			"        const int tm = (tl + tr) >> 1;",
			"        _linear_add(2 * k + 0, tl, tm, l, r, f);",
			"        _linear_add(2 * k + 1, tm, tr, l, r, f);",
			"        _update_bridge(k);",
			"    }",
			"    Int _min(int k, int tl, int tr, int l, int r, const Lazy& f) const {",
			"        if (tl >= r or tr <= l) return std::numeric_limits<Int>::max();",
			"        const Lazy nxt_f = f + _laz[k];",
			"        const int tm = (tl + tr) >> 1;",
			"        if (l <= tl and tr <= r) {",
			"            if (k >= _siz) return nxt_f.eval(tl);",
			"            auto [px, py] = _bridge[k].first;",
			"            auto [qx, qy] = _bridge[k].second;",
			"            if ((qy - py) + f.a * (qx - px) >= 0) {",
			"                return _min(2 * k + 0, tl, tm, l, r, nxt_f);",
			"            } else {",
			"                return _min(2 * k + 1, tm, tr, l, r, nxt_f);",
			"            }",
			"        }",
			"        return std::min(_min(2 * k + 0, tl, tm, l, r, nxt_f),",
			"                        _min(2 * k + 1, tm, tr, l, r, nxt_f));",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"CollectKing": {
		"prefix": "CollectKing",
		"body": [
			"struct CollectKing {",
			"    // 収集王構造体",
			"    // https://atcoder.jp/contests/abc298/tasks/abc298_f",
			"    // https://atcoder.jp/contests/abc176/tasks/abc176_e",
			"    int n;",
			"    vector<ll> input_x, input_y, input_v;",
			"    ll select_x, select_y;",
			"",
			"    CollectKing() : n(0) {}",
			"    void add(ll _x, ll _y, ll _v) {",
			"        input_x.push_back(_x);",
			"        input_y.push_back(_y);",
			"        input_v.push_back(_v);",
			"        n++;",
			"    }",
			"    ll solve(bool struct_select = false) {",
			"        vector<ll> x = input_x, y = input_y;",
			"        vector<tuple<ll, ll, ll>> info(n);",
			"        rep(i, 0, n) { info[i] = {input_x[i], input_y[i], input_v[i]}; }",
			"        sort(x.begin(), x.end());",
			"        sort(y.begin(), y.end());",
			"        x.erase(unique(x.begin(), x.end()), x.end());",
			"        y.erase(unique(y.begin(), y.end()), y.end());",
			"        int m = x.size(), k = y.size();",
			"        vector<ll> row(m), col(k);",
			"        vector t(m, vector<pair<ll, ll>>());",
			"        vector<pair<ll, ll>> mxc(k);",
			"        for (auto [r, c, v] : info) {",
			"            r = lower_bound(x.begin(), x.end(), r) - x.begin();",
			"            c = lower_bound(y.begin(), y.end(), c) - y.begin();",
			"            row[r] += v;",
			"            t[r].push_back({v, c});",
			"            col[c] += v;",
			"            mxc[c].first += v;",
			"            mxc[c].second = c;",
			"        }",
			"        sort(mxc.rbegin(), mxc.rend());",
			"        ll ans = 0;",
			"        set<ll> st;",
			"        for (int i = 0; i < m; i++) {",
			"            st.clear();",
			"            ll mx = 0;",
			"            for (auto &[x, c] : t[i]) {",
			"                x = col[c] - x;",
			"                st.insert(c);",
			"            }",
			"            sort(t[i].rbegin(), t[i].rend());",
			"            mx = row[i] + t[i][0].first;",
			"            for (auto [x, c] : mxc) {",
			"                if (st.find(c) == st.end()) {",
			"                    mx = max(mx, row[i] + x);",
			"                    break;",
			"                }",
			"            }",
			"            if (mx > ans) {",
			"                ans = mx;",
			"                select_x = x[i];",
			"            }",
			"        }",
			"        if (struct_select) {",
			"            map<ll, ll> sy;",
			"            for (auto [r, c, v] : info) {",
			"                if (r != select_x) sy[c] += v;",
			"            }",
			"            select_y = max_element(sy.begin(), sy.end(), [](auto a, auto b) {",
			"                           return a.second < b.second;",
			"                       })->first;",
			"        }",
			"        return ans;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"RectanglesUnion": {
		"prefix": "RectanglesUnion",
		"body": [
			"template <typename T>",
			"struct RectanglesUnion {",
			"    template <typename C>",
			"    struct IntervalAddEmptyCount {",
			"        int sz, height, n;",
			"        vector<C> data;",
			"        vector<int> lazy;",
			"        C M1 = 0;",
			"        int OM0 = 0;",
			"        IntervalAddEmptyCount(int n) {",
			"            sz = 1;",
			"            height = 0;",
			"            while (sz < n) sz <<= 1, height++;",
			"            data.assign(2 * sz, M1);",
			"            lazy.assign(2 * sz, OM0);",
			"        }",
			"        void set(ll k, const C &x) { data[k + sz] = x; }",
			"        void build() {",
			"            for (int k = sz - 1; k > 0; k--) {",
			"                data[k] = data[2 * k + 0] + data[2 * k + 1];",
			"            }",
			"        }",
			"        inline C reflect(int k) { return lazy[k] == OM0 ? data[k] : 0; }",
			"        inline void recalc(int k) {",
			"            while (k >>= 1) data[k] = reflect(2 * k + 0) + reflect(2 * k + 1);",
			"        }",
			"        void update(int a, int b, const int &x) {",
			"            if (a >= b) return;",
			"            a += sz;",
			"            b += sz - 1;",
			"            for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {",
			"                if (l & 1) lazy[l] += x, ++l;",
			"                if (r & 1) --r, lazy[r] += x;",
			"            }",
			"            recalc(a);",
			"            recalc(b);",
			"        }",
			"        C query() { return data[1]; }",
			"    };",
			"",
			"    RectanglesUnion() {}",
			"    vector<tuple<T, T, T, T>> add;",
			"    void add_rectangle(T xl, T xr, T yl, T yr) {",
			"        add.emplace_back(xl, xr, yl, yr);",
			"    }",
			"",
			"    ll solve() {",
			"        ll ret = 0;",
			"        vector<T> xc, yc;",
			"        int n = add.size();",
			"        xc.reserve(2 * n);",
			"        yc.reserve(2 * n);",
			"        for (int i = 0; i < add.size(); i++) {",
			"            auto [xl, xr, yl, yr] = add[i];",
			"            xc[2 * i] = xl, xc[2 * i + 1] = xr;",
			"            yc[2 * i] = yl, yc[2 * i + 1] = yr;",
			"        }",
			"        vector<int> ox(2 * n), oy(2 * n);",
			"        iota(ox.begin(), ox.end(), 0);",
			"        iota(oy.begin(), oy.end(), 0);",
			"        sort(ox.begin(), ox.end(), [&](int i, int j) { return xc[i] < xc[j]; });",
			"        sort(oy.begin(), oy.end(), [&](int i, int j) { return yc[i] < yc[j]; });",
			"        vector<int> iy(2 * n);",
			"        for (int i = 0; i < 2 * n; i++) iy[oy[i]] = i;",
			"        IntervalAddEmptyCount<int> seg(2 * n);",
			"        for (int i = 0; i < 2 * n - 1; i++) {",
			"            seg.set(i, yc[oy[i + 1]] - yc[oy[i]]);",
			"        }",
			"        seg.build();",
			"        int all = yc[oy.back()] - yc[oy[0]];",
			"        for (int i = 0; i < ox.size() - 1; i++) {",
			"            int k = ox[i] / 2;",
			"            if (ox[i] & 1)",
			"                seg.update(iy[2 * k], iy[2 * k + 1], -1);",
			"            else",
			"                seg.update(iy[2 * k], iy[2 * k + 1], +1);",
			"            ll tmp = seg.query();",
			"            ret += (all - tmp) * (xc[ox[i + 1]] - xc[ox[i]]);",
			"        }",
			"        return ret;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"PalQuery": {
		"prefix": "PalQuery",
		"body": [
			"struct PalQuery {",
			"    /**",
			"     * 回文判定クエリ",
			"     */",
			"    const int dummy_int = -1;",
			"    vector<int> pal_dat;",
			"",
			"    PalQuery() {}",
			"    PalQuery(string s) {",
			"        vector<int> v;",
			"        for (auto &nx : s) v.emplace_back(nx);",
			"        pal_dat = pal_build(v);",
			"    }",
			"    PalQuery(vector<int> v) { pal_dat = pal_build(v); }",
			"",
			"    // manacher algorithm",
			"    // http://snuke.hatenablog.com/entry/2014/12/02/235837",
			"",
			"    // longest palindrome(length:odd)",
			"    // if you want to find the answer for even palindrome,",
			"    // you can use dummy letter.",
			"    // ex. \\$a\\$b\\$c\\$c\\$b\\$a\\$",
			"    vector<int> manacher(vector<int> &s) {",
			"        int i, j, k, l;",
			"        l = s.size();",
			"        vector<int> arr(l);",
			"        i = 0;",
			"        j = 0;",
			"        while (i < l) {",
			"            while ((i - j) >= 0 && (i + j) < l) {",
			"                if (s[i - j] != s[i + j]) {",
			"                    break;",
			"                }",
			"                j++;",
			"            }",
			"            arr[i] = j;",
			"            k = 1;",
			"            while ((i - k) >= 0 && (i + k) < l) {",
			"                if (k + arr[i - k] >= arr[i]) {",
			"                    break;",
			"                }",
			"                arr[i + k] = arr[i - k];",
			"                k++;",
			"            }",
			"            j = arr[i] - k;",
			"            i += k;",
			"        }",
			"        return arr;",
			"    }",
			"",
			"    vector<int> pal_build(vector<int> v) {",
			"        vector<int> tmp;",
			"        tmp.emplace_back(dummy_int);",
			"        for (auto &nx : v) {",
			"            tmp.emplace_back(nx);",
			"            tmp.emplace_back(dummy_int);",
			"        }",
			"        return manacher(tmp);",
			"    }",
			"",
			"    // 0-indexed ask [l,r]",
			"    bool pal_ask(int l, int r) {",
			"        int len = r - l + 1;",
			"        int cent = l + r + 1;",
			"        return (pal_dat[cent] >= len);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"SegmentTree2D": {
		"prefix": "SegmentTree2D",
		"body": [
			"template <typename T, typename F>",
			"struct SegmentTree2D {",
			"    /**",
			"     * 二次元セグメント木",
			"     */",
			"   private:",
			"    int id(int h, int w) const { return h * 2 * W + w; }",
			"",
			"   public:",
			"    int H, W;",
			"    vector<T> seg;",
			"    const F f;",
			"    const T I;",
			"",
			"    SegmentTree2D() = default;",
			"    SegmentTree2D(int h, int w, F _f, const T& i) : f(_f), I(i) { init(h, w); }",
			"",
			"    void init(int h, int w) {",
			"        H = W = 1;",
			"        while (H < h) H <<= 1;",
			"        while (W < w) W <<= 1;",
			"        seg.assign(4 * H * W, I);",
			"    }",
			"",
			"    void set(int h, int w, const T& x) { seg[id(h + H, w + W)] = x; }",
			"",
			"    void build() {",
			"        // w in [W, 2W)",
			"        for (int w = W; w < 2 * W; w++) {",
			"            for (int h = H - 1; h; h--) {",
			"                seg[id(h, w)] = f(seg[id(2 * h + 0, w)], seg[id(2 * h + 1, w)]);",
			"            }",
			"        }",
			"        // h in [0, 2H)",
			"        for (int h = 0; h < 2 * H; h++) {",
			"            for (int w = W - 1; w; w--) {",
			"                seg[id(h, w)] = f(seg[id(h, 2 * w + 0)], seg[id(h, 2 * w + 1)]);",
			"            }",
			"        }",
			"    }",
			"",
			"    T get(int h, int w) const { return seg[id(h + H, w + W)]; }",
			"    T operator()(int h, int w) const { return seg[id(h + H, w + W)]; }",
			"",
			"    void update(int h, int w, const T& x) {",
			"        h += H, w += W;",
			"        seg[id(h, w)] = x;",
			"        for (int i = h >> 1; i; i >>= 1) {",
			"            seg[id(i, w)] = f(seg[id(2 * i + 0, w)], seg[id(2 * i + 1, w)]);",
			"        }",
			"        for (; h; h >>= 1) {",
			"            for (int j = w >> 1; j; j >>= 1) {",
			"                seg[id(h, j)] = f(seg[id(h, 2 * j + 0)], seg[id(h, 2 * j + 1)]);",
			"            }",
			"        }",
			"    }",
			"",
			"    T _inner_query(int h, int w1, int w2) {",
			"        T res = I;",
			"        for (; w1 < w2; w1 >>= 1, w2 >>= 1) {",
			"            if (w1 & 1) res = f(res, seg[id(h, w1)]), w1++;",
			"            if (w2 & 1) --w2, res = f(res, seg[id(h, w2)]);",
			"        }",
			"        return res;",
			"    }",
			"",
			"    // [h1,w1), [h2,w2) 半開区間",
			"    T query(int h1, int w1, int h2, int w2) {",
			"        if (h1 >= h2 || w1 >= w2) return I;",
			"        T res = I;",
			"        h1 += H, h2 += H, w1 += W, w2 += W;",
			"        for (; h1 < h2; h1 >>= 1, h2 >>= 1) {",
			"            if (h1 & 1) res = f(res, _inner_query(h1, w1, w2)), h1++;",
			"            if (h2 & 1) --h2, res = f(res, _inner_query(h2, w1, w2));",
			"        }",
			"        return res;",
			"    }",
			"",
			"    /**",
			"     * 使い方",
			"     *",
			"     * SegmentTree2D seg(h, w, op, e());",
			"     * init(h, w)",
			"     * set(h, w, x)     // build 前",
			"     * build()",
			"     * get(h, w)",
			"     * update(h, w, x)  // build 後",
			"     * query(h1, w1, h2, w2)",
			"     */",
			"};",
			"",
		],
		"description": ""
	},
	"SegmentTreeBeats": {
		"prefix": "SegmentTreeBeats",
		"body": [
			"class SegmentTreeBeats {",
			"    // https://tjkendev.github.io/procon-library/cpp/range_query/segment_tree_beats_2.html",
			"    const ll inf = 2e18;",
			"    int n, n0;",
			"    vector<ll> max_v, smax_v, max_c;",
			"    vector<ll> min_v, smin_v, min_c;",
			"    vector<ll> sum;",
			"    vector<ll> len, ladd, lval;",
			"",
			"    void update_node_max(int k, ll x) {",
			"        sum[k] += (x - max_v[k]) * max_c[k];",
			"",
			"        if (max_v[k] == min_v[k]) {",
			"            max_v[k] = min_v[k] = x;",
			"        } else if (max_v[k] == smin_v[k]) {",
			"            max_v[k] = smin_v[k] = x;",
			"        } else {",
			"            max_v[k] = x;",
			"        }",
			"",
			"        if (lval[k] != inf && x < lval[k]) {",
			"            lval[k] = x;",
			"        }",
			"    }",
			"    void update_node_min(int k, ll x) {",
			"        sum[k] += (x - min_v[k]) * min_c[k];",
			"",
			"        if (max_v[k] == min_v[k]) {",
			"            max_v[k] = min_v[k] = x;",
			"        } else if (smax_v[k] == min_v[k]) {",
			"            min_v[k] = smax_v[k] = x;",
			"        } else {",
			"            min_v[k] = x;",
			"        }",
			"",
			"        if (lval[k] != inf && lval[k] < x) {",
			"            lval[k] = x;",
			"        }",
			"    }",
			"",
			"    void push(int k) {",
			"        if (n0 - 1 <= k) return;",
			"",
			"        if (lval[k] != inf) {",
			"            updateall(2 * k + 1, lval[k]);",
			"            updateall(2 * k + 2, lval[k]);",
			"            lval[k] = inf;",
			"            return;",
			"        }",
			"",
			"        if (ladd[k] != 0) {",
			"            addall(2 * k + 1, ladd[k]);",
			"            addall(2 * k + 2, ladd[k]);",
			"            ladd[k] = 0;",
			"        }",
			"",
			"        if (max_v[k] < max_v[2 * k + 1]) {",
			"            update_node_max(2 * k + 1, max_v[k]);",
			"        }",
			"        if (min_v[2 * k + 1] < min_v[k]) {",
			"            update_node_min(2 * k + 1, min_v[k]);",
			"        }",
			"",
			"        if (max_v[k] < max_v[2 * k + 2]) {",
			"            update_node_max(2 * k + 2, max_v[k]);",
			"        }",
			"        if (min_v[2 * k + 2] < min_v[k]) {",
			"            update_node_min(2 * k + 2, min_v[k]);",
			"        }",
			"    }",
			"",
			"    void update(int k) {",
			"        sum[k] = sum[2 * k + 1] + sum[2 * k + 2];",
			"",
			"        if (max_v[2 * k + 1] < max_v[2 * k + 2]) {",
			"            max_v[k] = max_v[2 * k + 2];",
			"            max_c[k] = max_c[2 * k + 2];",
			"            smax_v[k] = max(max_v[2 * k + 1], smax_v[2 * k + 2]);",
			"        } else if (max_v[2 * k + 1] > max_v[2 * k + 2]) {",
			"            max_v[k] = max_v[2 * k + 1];",
			"            max_c[k] = max_c[2 * k + 1];",
			"            smax_v[k] = max(smax_v[2 * k + 1], max_v[2 * k + 2]);",
			"        } else {",
			"            max_v[k] = max_v[2 * k + 1];",
			"            max_c[k] = max_c[2 * k + 1] + max_c[2 * k + 2];",
			"            smax_v[k] = max(smax_v[2 * k + 1], smax_v[2 * k + 2]);",
			"        }",
			"",
			"        if (min_v[2 * k + 1] < min_v[2 * k + 2]) {",
			"            min_v[k] = min_v[2 * k + 1];",
			"            min_c[k] = min_c[2 * k + 1];",
			"            smin_v[k] = min(smin_v[2 * k + 1], min_v[2 * k + 2]);",
			"        } else if (min_v[2 * k + 1] > min_v[2 * k + 2]) {",
			"            min_v[k] = min_v[2 * k + 2];",
			"            min_c[k] = min_c[2 * k + 2];",
			"            smin_v[k] = min(min_v[2 * k + 1], smin_v[2 * k + 2]);",
			"        } else {",
			"            min_v[k] = min_v[2 * k + 1];",
			"            min_c[k] = min_c[2 * k + 1] + min_c[2 * k + 2];",
			"            smin_v[k] = min(smin_v[2 * k + 1], smin_v[2 * k + 2]);",
			"        }",
			"    }",
			"",
			"    void _update_min(ll x, int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a || max_v[k] <= x) {",
			"            return;",
			"        }",
			"        if (a <= l && r <= b && smax_v[k] < x) {",
			"            update_node_max(k, x);",
			"            return;",
			"        }",
			"",
			"        push(k);",
			"        _update_min(x, a, b, 2 * k + 1, l, (l + r) / 2);",
			"        _update_min(x, a, b, 2 * k + 2, (l + r) / 2, r);",
			"        update(k);",
			"    }",
			"",
			"    void _update_max(ll x, int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a || x <= min_v[k]) {",
			"            return;",
			"        }",
			"        if (a <= l && r <= b && x < smin_v[k]) {",
			"            update_node_min(k, x);",
			"            return;",
			"        }",
			"",
			"        push(k);",
			"        _update_max(x, a, b, 2 * k + 1, l, (l + r) / 2);",
			"        _update_max(x, a, b, 2 * k + 2, (l + r) / 2, r);",
			"        update(k);",
			"    }",
			"",
			"    void addall(int k, ll x) {",
			"        max_v[k] += x;",
			"        if (smax_v[k] != -inf) smax_v[k] += x;",
			"        min_v[k] += x;",
			"        if (smin_v[k] != inf) smin_v[k] += x;",
			"",
			"        sum[k] += len[k] * x;",
			"        if (lval[k] != inf) {",
			"            lval[k] += x;",
			"        } else {",
			"            ladd[k] += x;",
			"        }",
			"    }",
			"",
			"    void updateall(int k, ll x) {",
			"        max_v[k] = x;",
			"        smax_v[k] = -inf;",
			"        min_v[k] = x;",
			"        smin_v[k] = inf;",
			"        max_c[k] = min_c[k] = len[k];",
			"",
			"        sum[k] = x * len[k];",
			"        lval[k] = x;",
			"        ladd[k] = 0;",
			"    }",
			"",
			"    void _add_val(ll x, int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a) {",
			"            return;",
			"        }",
			"        if (a <= l && r <= b) {",
			"            addall(k, x);",
			"            return;",
			"        }",
			"",
			"        push(k);",
			"        _add_val(x, a, b, 2 * k + 1, l, (l + r) / 2);",
			"        _add_val(x, a, b, 2 * k + 2, (l + r) / 2, r);",
			"        update(k);",
			"    }",
			"",
			"    void _update_val(ll x, int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a) {",
			"            return;",
			"        }",
			"        if (a <= l && r <= b) {",
			"            updateall(k, x);",
			"            return;",
			"        }",
			"",
			"        push(k);",
			"        _update_val(x, a, b, 2 * k + 1, l, (l + r) / 2);",
			"        _update_val(x, a, b, 2 * k + 2, (l + r) / 2, r);",
			"        update(k);",
			"    }",
			"",
			"    ll _query_max(int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a) {",
			"            return -inf;",
			"        }",
			"        if (a <= l && r <= b) {",
			"            return max_v[k];",
			"        }",
			"        push(k);",
			"        ll lv = _query_max(a, b, 2 * k + 1, l, (l + r) / 2);",
			"        ll rv = _query_max(a, b, 2 * k + 2, (l + r) / 2, r);",
			"        return max(lv, rv);",
			"    }",
			"",
			"    ll _query_min(int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a) {",
			"            return inf;",
			"        }",
			"        if (a <= l && r <= b) {",
			"            return min_v[k];",
			"        }",
			"        push(k);",
			"        ll lv = _query_min(a, b, 2 * k + 1, l, (l + r) / 2);",
			"        ll rv = _query_min(a, b, 2 * k + 2, (l + r) / 2, r);",
			"        return min(lv, rv);",
			"    }",
			"",
			"    ll _query_sum(int a, int b, int k, int l, int r) {",
			"        if (b <= l || r <= a) {",
			"            return 0;",
			"        }",
			"        if (a <= l && r <= b) {",
			"            return sum[k];",
			"        }",
			"        push(k);",
			"        ll lv = _query_sum(a, b, 2 * k + 1, l, (l + r) / 2);",
			"        ll rv = _query_sum(a, b, 2 * k + 2, (l + r) / 2, r);",
			"        return lv + rv;",
			"    }",
			"",
			"   public:",
			"    SegmentTreeBeats(int n, ll *a) : n(n) { initSegmentTree(n, a); }",
			"    SegmentTreeBeats(int n) : n(n) { initSegmentTree(n, nullptr); }",
			"    SegmentTreeBeats(vector<ll> a) {",
			"        n = a.size();",
			"        initSegmentTree(n, a.data());",
			"    }",
			"",
			"    void initSegmentTree(int n, ll *a) {",
			"        n0 = 1;",
			"        while (n0 < n) n0 <<= 1;",
			"",
			"        max_v = smax_v = max_c = vector<ll>(2 * n0, -inf);",
			"        min_v = smin_v = min_c = vector<ll>(2 * n0, inf);",
			"        sum = vector<ll>(2 * n0, 0);",
			"        ladd = vector<ll>(2 * n0, 0);",
			"        lval = vector<ll>(2 * n0, inf);",
			"        len = vector<ll>(2 * n0, 0);",
			"",
			"        for (int i = 0; i < 2 * n0; ++i) ladd[i] = 0, lval[i] = inf;",
			"        len[0] = n0;",
			"        for (int i = 0; i < n0 - 1; ++i)",
			"            len[2 * i + 1] = len[2 * i + 2] = (len[i] >> 1);",
			"",
			"        for (int i = 0; i < n; ++i) {",
			"            max_v[n0 - 1 + i] = min_v[n0 - 1 + i] = sum[n0 - 1 + i] =",
			"                (a != nullptr ? a[i] : 0);",
			"            smax_v[n0 - 1 + i] = -inf;",
			"            smin_v[n0 - 1 + i] = inf;",
			"            max_c[n0 - 1 + i] = min_c[n0 - 1 + i] = 1;",
			"        }",
			"",
			"        for (int i = n; i < n0; ++i) {",
			"            max_v[n0 - 1 + i] = smax_v[n0 - 1 + i] = -inf;",
			"            min_v[n0 - 1 + i] = smin_v[n0 - 1 + i] = inf;",
			"            max_c[n0 - 1 + i] = min_c[n0 - 1 + i] = 0;",
			"        }",
			"        for (int i = n0 - 2; i >= 0; i--) {",
			"            update(i);",
			"        }",
			"    }",
			"",
			"    // range minimize query",
			"    void update_min(int a, int b, ll x) { _update_min(x, a, b, 0, 0, n0); }",
			"",
			"    // range maximize query",
			"    void update_max(int a, int b, ll x) { _update_max(x, a, b, 0, 0, n0); }",
			"",
			"    // range add query",
			"    void add_val(int a, int b, ll x) { _add_val(x, a, b, 0, 0, n0); }",
			"",
			"    // range update query",
			"    void update_val(int a, int b, ll x) { _update_val(x, a, b, 0, 0, n0); }",
			"",
			"    // range minimum query",
			"    ll query_max(int a, int b) { return _query_max(a, b, 0, 0, n0); }",
			"",
			"    // range maximum query",
			"    ll query_min(int a, int b) { return _query_min(a, b, 0, 0, n0); }",
			"",
			"    // range sum query",
			"    ll query_sum(int a, int b) { return _query_sum(a, b, 0, 0, n0); }",
			"};",
			"",
		],
		"description": ""
	},
	"Trie": {
		"prefix": "Trie",
		"body": [
			"template <int char_size> struct TrieNode {",
			"    int nxt[char_size];",
			"",
			"    int exist;",
			"    vector<int> accept;",
			"",
			"    TrieNode() : exist(0) { memset(nxt, -1, sizeof(nxt)); }",
			"};",
			"",
			"template <int char_size, int margin> struct Trie {",
			"    // https://ei1333.github.io/luzhiled/snippets/structure/trie.html",
			"    using Node = TrieNode<char_size>;",
			"",
			"    vector<Node> nodes;",
			"    int root;",
			"",
			"    Trie() : root(0) { nodes.push_back(Node()); }",
			"",
			"    void update_direct(int node, int id) { nodes[node].accept.push_back(id); }",
			"",
			"    void update_child(int node, int child, int id) { ++nodes[node].exist; }",
			"",
			"    void add(const string &str, int str_index, int node_index, int id) {",
			"        if (str_index == str.size()) {",
			"            update_direct(node_index, id);",
			"        } else {",
			"            const int c = str[str_index] - margin;",
			"            if (nodes[node_index].nxt[c] == -1) {",
			"                nodes[node_index].nxt[c] = (int)nodes.size();",
			"                nodes.push_back(Node());",
			"            }",
			"            add(str, str_index + 1, nodes[node_index].nxt[c], id);",
			"            update_child(node_index, nodes[node_index].nxt[c], id);",
			"        }",
			"    }",
			"",
			"    void add(const string &str, int id) { add(str, 0, 0, id); }",
			"",
			"    void add(const string &str) { add(str, nodes[0].exist); }",
			"",
			"    void query(const string &str, const function<void(int)> &f, int str_index,",
			"               int node_index) {",
			"        for (auto &idx : nodes[node_index].accept)",
			"            f(idx);",
			"        if (str_index == str.size()) {",
			"            return;",
			"        } else {",
			"            const int c = str[str_index] - margin;",
			"            if (nodes[node_index].nxt[c] == -1)",
			"                return;",
			"            query(str, f, str_index + 1, nodes[node_index].nxt[c]);",
			"        }",
			"    }",
			"",
			"    void query(const string &str, const function<void(int)> &f) {",
			"        query(str, f, 0, 0);",
			"    }",
			"",
			"    int count() const { return (nodes[0].exist); }",
			"",
			"    int size() const { return ((int)nodes.size()); }",
			"};",
			"",
		],
		"description": ""
	},
	"AhoCorasick": {
		"prefix": "AhoCorasick",
		"body": [
			"template <int char_size, int margin>",
			"struct AhoCorasick : Trie<char_size + 1, margin> {",
			"    // https://ei1333.github.io/library/string/aho-corasick.hpp.html",
			"    using Trie<char_size + 1, margin>::Trie;",
			"",
			"    const int FAIL = char_size;",
			"    vector<int> correct;",
			"",
			"    void build(bool heavy = true) {",
			"        correct.resize(this->size());",
			"        for (int i = 0; i < this->size(); i++) {",
			"            correct[i] = (int)this->nodes[i].accept.size();",
			"        }",
			"        queue<int> que;",
			"        for (int i = 0; i <= char_size; i++) {",
			"            if (~this->nodes[0].nxt[i]) {",
			"                this->nodes[this->nodes[0].nxt[i]].nxt[FAIL] = 0;",
			"                que.emplace(this->nodes[0].nxt[i]);",
			"            } else {",
			"                this->nodes[0].nxt[i] = 0;",
			"            }",
			"        }",
			"        while (!que.empty()) {",
			"            auto &now = this->nodes[que.front()];",
			"            int fail = now.nxt[FAIL];",
			"            correct[que.front()] += correct[fail];",
			"            que.pop();",
			"            for (int i = 0; i < char_size; i++) {",
			"                if (~now.nxt[i]) {",
			"                    this->nodes[now.nxt[i]].nxt[FAIL] =",
			"                        this->nodes[fail].nxt[i];",
			"                    if (heavy) {",
			"                        auto &u = this->nodes[now.nxt[i]].accept;",
			"                        auto &v = this->nodes[this->nodes[fail].nxt[i]].accept;",
			"                        vector<int> accept;",
			"                        set_union(begin(u), end(u), begin(v), end(v),",
			"                                  back_inserter(accept));",
			"                        u = accept;",
			"                    }",
			"                    que.emplace(now.nxt[i]);",
			"                } else {",
			"                    now.nxt[i] = this->nodes[fail].nxt[i];",
			"                }",
			"            }",
			"        }",
			"    }",
			"",
			"    unordered_map<int, int> match(const string &str, int now = 0) {",
			"        unordered_map<int, int> result, visit_cnt;",
			"        for (auto &c : str) {",
			"            now = this->nodes[now].nxt[c - margin];",
			"            visit_cnt[now]++;",
			"        }",
			"        for (auto &[now, cnt] : visit_cnt) {",
			"            for (auto &v : this->nodes[now].accept)",
			"                result[v] += cnt;",
			"        }",
			"        return result;",
			"    }",
			"",
			"    pair<int64_t, int> move(const char &c, int now = 0) {",
			"        now = this->nodes[now].nxt[c - margin];",
			"        return {correct[now], now};",
			"    }",
			"",
			"    pair<int64_t, int> move(const string &str, int now = 0) {",
			"        int64_t sum = 0;",
			"        for (auto &c : str) {",
			"            auto nxt = move(c, now);",
			"            sum += nxt.first;",
			"            now = nxt.second;",
			"        }",
			"        return {sum, now};",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"BipartiteMatching": {
		"prefix": "BipartiteMatching",
		"body": [
			"struct BipartiteMatching {",
			"    int n, m;",
			"    vector<vector<int>> gr;",
			"    vector<int> match, alive, used, u, v;",
			"    int timestamp;",
			"",
			"    vector<int> select, type;",
			"",
			"    BipartiteMatching() : n(0), m(0) {}",
			"    BipartiteMatching(int n, int m) : n(n), m(m) { gr.resize(n + m); }",
			"",
			"    void add_edge(int a, int b) {",
			"        assert(0 <= a && a < n);",
			"        assert(0 <= b && b < m);",
			"        u.push_back(a);",
			"        v.push_back(b);",
			"        gr[a].push_back(n + b);",
			"        gr[n + b].push_back(a);",
			"    }",
			"",
			"    int solve(bool construct = false, bool typecheck = false) {",
			"        timestamp = 0;",
			"        match = vector<int>(n + m, -1);",
			"        alive = vector<int>(n + m, 1);",
			"        used = vector<int>(n + m, 0);",
			"",
			"        auto dfs = [&](auto &&dfs, int v) -> bool {",
			"            used[v] = timestamp;",
			"            for (int i = 0; i < gr[v].size(); i++) {",
			"                int u = gr[v][i], w = match[u];",
			"                if (alive[u] == 0)",
			"                    continue;",
			"                if (w == -1 || (used[w] != timestamp && dfs(dfs, w))) {",
			"                    match[v] = u;",
			"                    match[u] = v;",
			"                    return true;",
			"                }",
			"            }",
			"            return false;",
			"        };",
			"",
			"        int ret = 0;",
			"        for (int i = 0; i < n + m; i++) {",
			"            if (alive[i] == 0)",
			"                continue;",
			"            if (match[i] == -1) {",
			"                ++timestamp;",
			"                ret += dfs(dfs, i);",
			"            }",
			"        }",
			"        if (construct) {",
			"            int l = u.size();",
			"            select = vector<int>(l, 0);",
			"            for (int i = 0; i < l; i++) {",
			"                if (match[u[i]] == v[i] + n) {",
			"                    select[i] = 1;",
			"                }",
			"            }",
			"        }",
			"        if (typecheck) {",
			"            // type[i] = 1: 必ずマッチングに含める",
			"            // type[i] = 0: 任意",
			"            // type[i] = -1: 必ずマッチングに含めない",
			"            int l = u.size();",
			"            type = vector<int>(l);",
			"            atcoder::scc_graph scc_gr(n + m + 2);",
			"            for (int i = 0; i < l; i++) {",
			"                if (match[u[i]] == v[i] + n)",
			"                    scc_gr.add_edge(v[i] + n, u[i]);",
			"                else",
			"                    scc_gr.add_edge(u[i], v[i] + n);",
			"            }",
			"            for (int i = 0; i < n; i++) {",
			"                if (match[i] == -1)",
			"                    scc_gr.add_edge(n + m, i);",
			"                else",
			"                    scc_gr.add_edge(i, n + m);",
			"            }",
			"            for (int i = n; i < n + m; i++) {",
			"                if (match[i] == -1)",
			"                    scc_gr.add_edge(i, n + m + 1);",
			"                else",
			"                    scc_gr.add_edge(n + m + 1, i);",
			"            }",
			"            auto scc = scc_gr.scc();",
			"            vector<int> scc_ind(n + m + 2, -1);",
			"            for (int i = 0; i < scc.size(); i++) {",
			"                for (int j : scc[i])",
			"                    scc_ind[j] = i;",
			"            }",
			"            for (int i = 0; i < l; i++) {",
			"                if (scc_ind[u[i]] == scc_ind[v[i] + n]) {",
			"                    type[i] = 0;",
			"                } else if (match[u[i]] == v[i] + n) {",
			"                    type[i] = 1;",
			"                } else {",
			"                    type[i] = -1;",
			"                }",
			"            }",
			"        }",
			"        return ret;",
			"    }",
			"};",
			"",
		],
		"description": "二部グラフ最大マッチング"
	},
	"RangeAPQuery": {
		"prefix": "RangeAPQuery",
		"body": [
			"struct RangeAPQuery {",
			"    // 等差数列add, 区間sumクエリ",
			"    int n;",
			"    vector<ll> v, pre;",
			"",
			"    RangeAPQuery(int input) {",
			"        n = input;",
			"        v.resize(n);",
			"        pre.resize(n + 2);",
			"    }",
			"    void add(ll l, ll r, ll a0, ll d) {",
			"        // 初項 a0, 等差 d",
			"        // [l, r) <- +{a_i}",
			"        assert(l <= r);",
			"        pre[l] += a0;",
			"        pre[l + 1] += d - a0;",
			"        pre[r] -= a0 + d * (r - l);",
			"        pre[r + 1] += a0 + d * (r - l) - d;",
			"    }",
			"    void make() {",
			"        rep(i, 0, pre.size() - 1) pre[i + 1] += pre[i];",
			"        rep(i, 0, pre.size() - 1) pre[i + 1] += pre[i];",
			"        rep(i, 0, n) {",
			"            v[i] += pre[i];",
			"            pre[i] = 0;",
			"        }",
			"    }",
			"    ll get(int ind) { return v[ind]; }",
			"};",
			"",
		],
		"description": ""
	},
	"GraphToDAG": {
		"prefix": "GraphToDAG",
		"body": [
			"struct GraphToDAG {",
			"    int n, m;",
			"    vector<int> u, v;",
			"",
			"    GraphToDAG(int n) : n(n), m(0) {}",
			"",
			"    void add_edge(int from, int to) {",
			"        u.push_back(from);",
			"        v.push_back(to);",
			"        m++;",
			"    }",
			"",
			"    tuple<int, vector<pair<int, int>>, vector<int>> solve() {",
			"        scc_graph gr(n);",
			"        for (int i = 0; i < m; i++) {",
			"            gr.add_edge(u[i], v[i]);",
			"        }",
			"        auto scc = gr.scc();",
			"        int scc_count = (int)scc.size();",
			"        vector<int> convert(n);",
			"        for (int i = 0; i < scc_count; i++) {",
			"            for (int node : scc[i]) {",
			"                convert[node] = i;",
			"            }",
			"        }",
			"        vector<pair<int, int>> dag_edges;",
			"        dag_edges.reserve(m);",
			"        for (int i = 0; i < m; i++) {",
			"            int comp_u = convert[u[i]];",
			"            int comp_v = convert[v[i]];",
			"            if (comp_u != comp_v) {",
			"                dag_edges.push_back({comp_u, comp_v});",
			"            }",
			"        }",
			"        return {scc_count, dag_edges, convert};",
			"    }",
			"};",
		],
		"description": ""
	},
	"dance": {
		"prefix": "dance",
		"body": [
			"vector<vector<pair<int, int>>> dance(int n) {",
			"    bool odd = n % 2;",
			"    vector<vector<pair<int, int>>> ret;",
			"    vector<pair<int, int>> tmp;",
			"    vector<bool> used(n + odd);",
			"    auto f = [&](auto f, int i) -> void {",
			"        if (i == n + odd) {",
			"            ret.push_back(tmp);",
			"            return;",
			"        }",
			"        if (used[i]) {",
			"            f(f, i + 1);",
			"            return;",
			"        }",
			"        used[i] = true;",
			"        rep(j, i + 1, n + odd) {",
			"            if (used[j]) continue;",
			"            used[j] = true;",
			"            if (j != n) tmp.push_back({i, j});",
			"            f(f, i + 1);",
			"            if (j != n) tmp.pop_back();",
			"            used[j] = false;",
			"        }",
			"        used[i] = false;",
			"    };",
			"    f(f, 0);",
			"    return ret;",
			"}",
		],
		"description": ""
	},
	"sqrt_ll": {
		"prefix": "sqrt_ll",
		"body": [
			"ll sqrt_ll(ll n) {",
			"    // return floor(√n)",
			"    auto check = [&](ll mid) {",
			"        if (mid * mid <= n)",
			"            return true;",
			"        else",
			"            return false;",
			"    };",
			"    auto binary = [&]() {",
			"        ll L = 0, R = 3000000010;  // [L,R)の範囲内に解",
			"        ll mid = (L + R) / 2;",
			"        while (R - L > 1) {",
			"            if (check(mid))",
			"                L = mid;",
			"            else",
			"                R = mid;",
			"            mid = (L + R) / 2;",
			"        }",
			"        return L;  // L-true R-false",
			"    };",
			"    ll ret = binary();",
			"    return ret;",
			"}",
		],
		"description": ""
	},
	"lagrange_interpolation": {
		"prefix": "lagrange_interpolation",
		"body": [
			"vector<mint> lagrange_interpolation(vector<mint> x, vector<mint> y) {",
			"    // x座標が相異なる n+1 点(x_i, y_i)を通る n 次以下の多項式 f(x) を返す",
			"    // O(n^2)",
			"    const ll n = x.size() - 1;",
			"    rep(i, 0, n + 1) {",
			"        mint t = 1;",
			"        rep(j, 0, n + 1) if (i != j) t *= x[i] - x[j];",
			"        y[i] /= t;",
			"    }",
			"    ll cur = 0, nxt = 1;",
			"    vector<vector<mint>> dp(2, vector<mint>(n + 2));",
			"    dp[0][0] = -1 * x[0], dp[0][1] = 1;",
			"    rep(i, 1, n + 1) {",
			"        rep(j, 0, n + 2) {",
			"            dp[nxt][j] = dp[cur][j] * -1 * x[i];",
			"            if (j >= 1) dp[nxt][j] += dp[cur][j - 1];",
			"        }",
			"        swap(nxt, cur);",
			"    }",
			"    vector<mint> xinv(n + 1);",
			"    rep(i, 0, n + 1) {",
			"        if (x[i] == 0) continue;",
			"        xinv[i] = x[i].inv();",
			"    }",
			"    vector<mint> ret(n + 1);  // f(x)",
			"    rep(i, 0, n + 1) {",
			"        if (y[i].val() == 0) continue;",
			"        // 0割り対策の場合分け",
			"        if (x[i].val() == 0) {",
			"            rep(j, 0, n + 1) ret[j] += dp[cur][j + 1] * y[i];",
			"        } else {",
			"            ret[0] -= dp[cur][0] * xinv[i] * y[i];",
			"            mint pre = -1 * dp[cur][0] * xinv[i];",
			"            rep(j, 1, n + 1) {",
			"                ret[j] -= (dp[cur][j] - pre) * xinv[i] * y[i];",
			"                pre = -1 * (dp[cur][j] - pre) * xinv[i];",
			"            }",
			"        }",
			"    }",
			"    return ret;",
			"}",
			"",
			"mint lagrange_interpolation_arithmetic(ll a, ll d, vector<mint> y, ll t) {",
			"    // x座標が相異なる n+1 点(x_i, y_i)を通る n 次以下の多項式 f(T) の値を返す",
			"    // x = {a, a+d, a+2d, ... }",
			"    // O(nlog(MOD))",
			"    long long n = y.size() - 1;",
			"    long long L = a;",
			"    long long R = a + d * n;",
			"    bool ok = !(L <= t && t <= R && ((t - a) % d == 0));",
			"    if (!ok) {",
			"        return y[(t - a) / d];",
			"    }",
			"    mint ma = a, md = d;",
			"    mint T = t;",
			"    mint ret = 0, ft = 1;",
			"    rep(i, 0, n + 1) ft *= T - (ma + md * i);",
			"    mint f = 1;",
			"    rep(i, 1, n + 1) f *= -1 * i * md;",
			"    ret += y[0] / f * ft / (T - ma);",
			"    rep(i, 0, n) {",
			"        f *= md * (i + 1) / (md * (i - n));",
			"        ret += y[i + 1] / f * ft / (T - ma - md * (i + 1));",
			"    }",
			"    return ret;",
			"}",
			"",
		],
		"description": ""
	},
	"run_length": {
		"prefix": "run_length",
		"body": [
			"template <typename T>",
			"vector<pair<T, int>> run_length(vector<T> &a) {",
			"    int n = a.size();",
			"    vector<pair<T, int>> ret;",
			"    int now = 1;",
			"    rep(i, 0, n - 1) {",
			"        if (a[i] == a[i + 1])",
			"            now++;",
			"        else {",
			"            ret.push_back(make_pair(a[i], now));",
			"            now = 1;",
			"        }",
			"    }",
			"    ret.push_back(make_pair(a.back(), now));",
			"    // 環状かつ開始位置任意の場合",
			"    // if (ret.size() > 1 && ret[0].FI == ret.back().FI) {",
			"    //     ret[0].SE += ret.back().SE;",
			"    //     ret.pop_back();",
			"    // }",
			"    return ret;",
			"}",
		],
		"description": ""
	},
	"run_length_str": {
		"prefix": "run_length_str",
		"body": [
			"vector<pair<char, int>> run_length_str(string &a) {",
			"    int n = a.size();",
			"    vector<pair<char, int>> ret;",
			"    int now = 1;",
			"    rep(i, 0, n - 1) {",
			"        if (a[i] == a[i + 1])",
			"            now++;",
			"        else {",
			"            ret.push_back(make_pair(a[i], now));",
			"            now = 1;",
			"        }",
			"    }",
			"    ret.push_back(make_pair(a.back(), now));",
			"    // 環状かつ開始位置任意の場合",
			"    // if (ret.size() > 1 && ret[0].FI == ret.back().FI) {",
			"    //     ret[0].SE += ret.back().SE;",
			"    //     ret.pop_back();",
			"    // }",
			"    return ret;",
			"}",
		],
		"description": ""
	},
	"count_gcd": {
		"prefix": "count_gcd",
		"body": [
			"ll count_gcd(ll n, ll m, ll k) {",
			"    // gcd(n, [1,m]) == k",
			"    ll ret = 0;",
			"    vector<ll> v;",
			"    if (n % k != 0) return 0;",
			"    if (n == k) return m / n;",
			"    n /= k;",
			"    m /= k;",
			"    ll nn = n;",
			"    for (ll i = 2; i * i <= nn; ++i) {",
			"        if (nn % i) continue;",
			"        v.push_back(i);",
			"        while (nn % i == 0) nn /= i;",
			"    }",
			"    if (nn != 1) v.push_back(nn);",
			"    int len = v.size();",
			"    rep(i, 0, (1 << len)) {",
			"        ll nw = 1;",
			"        rep(j, 0, len) if (1 & (i >> j)) nw *= v[j];",
			"        ll ad = m / nw;",
			"        bool even = __builtin_popcountll(i) % 2;",
			"        if (even) ad *= -1;",
			"        ret += ad;",
			"    }",
			"    return ret;",
			"}",
		],
		"description": ""
	},
	"prufer_to_tree": {
		"prefix": "prufer_to_tree",
		"body": [
			"vector<pair<int, int>> prufer_to_tree(const vector<int>& prufer_code) {",
			"    int n = (int)prufer_code.size() + 2;",
			"    vector<int> degree(n, 1);",
			"    for (int i = 0; i < n - 2; ++i) ++degree[prufer_code[i]];",
			"    int ptr = 0;",
			"    while (ptr < n && degree[ptr] != 1) ++ptr;",
			"    int leaf = ptr;",
			"    vector<pair<int, int>> result;",
			"    for (int i = 0; i < n - 2; ++i) {",
			"        int v = prufer_code[i];",
			"        result.push_back(make_pair(leaf, v));",
			"        --degree[leaf];",
			"        if (--degree[v] == 1 && v < ptr)",
			"            leaf = v;",
			"        else {",
			"            ++ptr;",
			"            while (ptr < n && degree[ptr] != 1) ++ptr;",
			"            leaf = ptr;",
			"        }",
			"    }",
			"    for (int v = 0; v < n - 1; ++v)",
			"        if (degree[v] == 1) result.push_back(make_pair(v, n - 1));",
			"    return result;",
			"}",
			"",
		],
		"description": ""
	},
	"tree_to_prufer": {
		"prefix": "tree_to_prufer",
		"body": [
			"vector<int> tree_to_prufer(vector<pair<int, int>> tr) {",
			"    int n = tr.size() + 1;",
			"    vector<int> deg(n);",
			"    vector<vector<int>> gr(n);",
			"    for (auto e : tr) {",
			"        deg[e.first]++;",
			"        deg[e.second]++;",
			"        gr[e.first].push_back(e.second);",
			"        gr[e.second].push_back(e.first);",
			"    }",
			"    priority_queue<int, vector<int>, greater<int>> q;",
			"    for (int i = 0; i < n; i++) {",
			"        if (deg[i] == 1) {",
			"            q.push(i);",
			"        }",
			"    }",
			"    vector<int> res;",
			"    while (!q.empty()) {",
			"        int v = q.top();",
			"        q.pop();",
			"        deg[v]--;",
			"        for (auto u : gr[v]) {",
			"            if (deg[u] > 0) {",
			"                res.push_back(u);",
			"                deg[u]--;",
			"                if (deg[u] == 1) {",
			"                    q.push(u);",
			"                }",
			"            }",
			"        }",
			"    }",
			"    res.pop_back();",
			"    return res;",
			"}",
		],
		"description": ""
	},
	"string_matching": {
		"prefix": "string_matching",
		"body": [
			"template <int mod = 1811939329>",
			"vector<bool> string_matching(const vector<int>& s, const vector<int>& pattern) {",
			"    // s = \"__A_BCA__\"",
			"    // pattern = \"ABC\"",
			"    using modint = atcoder::static_modint<mod>;",
			"    int m = s.size();",
			"    int n = pattern.size();",
			"    assert(n <= m);",
			"    vector<modint> sum(m - n + 1, 0);",
			"",
			"    const auto add = [&](const auto f, const auto g) {",
			"        vector<modint> x(n), y(m);",
			"        for (int i = 0; i != n; ++i) {",
			"            x[i] = f(pattern[n - 1 - i]);",
			"        }",
			"        for (int i = 0; i != m; ++i) {",
			"            y[i] = g(s[i]);",
			"        }",
			"        const auto z = atcoder::convolution(x, y);",
			"        for (int i = 0; i != m - n + 1; ++i) {",
			"            sum[i] += z[n - 1 + i];",
			"        }",
			"    };",
			"",
			"    add([](const int v) { return modint(v) * v; },",
			"        [](const int v) { return int(v != 0); });",
			"    add([](const int v) { return modint(-2) * (v != 0) * v; },",
			"        [](const int v) { return int(v != 0) * v; });",
			"    add([](const int v) { return int(v != 0); },",
			"        [](const int v) { return modint(v != 0) * v * v; });",
			"    vector<bool> ret(m - n + 1, true);",
			"    for (int i = 0; i < m - n + 1; i++) {",
			"        if (sum[i].val() != 0) {",
			"            ret[i] = false;",
			"        }",
			"    }",
			"    return ret;",
			"}",
			"",
		],
		"description": ""
	},
	"mod_cerr": {
		"prefix": "mod_cerr",
		"body": [
			"void mod_cerr(mint n) {",
			"    rep(i, 0, 1000) rep(j, 1, 1000) {",
			"        mint nw = i;",
			"        nw /= j;",
			"        if (nw == n) {",
			"            cout << i << \"/\" << j << endl;",
			"            return;",
			"        }",
			"    }",
			"}",
		],
		"description": ""
	},
	"calc_include_subsets": {
		"prefix": "calc_include_subsets",
		"body": [
			"vector<modint998244353> calc_include_subsets(vector<int> v, int k,",
			"                                             bool vacant_ok = false) {",
			"    /**",
			"     * a[i0] | a[i1] | ...  が bit を完全に含むような部分集合の個数",
			"     * [0, 1<<k) すべてについて計算",
			"     */",
			"    modint998244353 ret = 0;",
			"    int mod = ret.mod();",
			"    int n = v.size();",
			"    vector<int> bits(1 << k);",
			"    for (int i : v) bits[i]++;",
			"    for (int d = 0; d < k; d++)",
			"        for (int i = 0; i < 1 << k; i++)",
			"            if (!(i & 1 << d)) bits[i | 1 << d] += bits[i];",
			"    reverse(begin(bits), end(bits));",
			"    vector<modint998244353> dp(1 << k);",
			"    rep(i, 0, 1 << k) {",
			"        int t = pow_mod(2, bits[i], mod) - 1 + vacant_ok;",
			"        rep(d, 0, k) if (i & 1 << d) t = -t;",
			"        dp[i] = t;",
			"    }",
			"    for (int d = 0; d < k; d++)",
			"        for (int i = 0; i < 1 << k; i++)",
			"            if (i & 1 << d) dp[i] += dp[i ^ 1 << d];",
			"    return dp;",
			"}",
			"",
		],
		"description": ""
	},
	"max_pal_len": {
		"prefix": "max_pal_len",
		"body": [
			"int max_pal_len(string s) {",
			"    // 回文の最大半径を返す",
			"    int ret = 0;",
			"",
			"    // 奇数長",
			"    vector<int> odd(s.size());",
			"    for (int i = 0, l = 0, r = -1; i < s.size(); i++) {",
			"        int k = (i > r) ? 1 : min(odd[l + r - i], r - i);",
			"        while (0 <= i - k && i + k < s.size() && s[i - k] == s[i + k])",
			"            k++;",
			"        odd[i] = k--;",
			"        ret = max(ret, k * 2 + 1);",
			"        if (i + k > r)",
			"            l = i - k, r = i + k;",
			"    }",
			"    ret = max(ret, *max_element(odd.begin(), odd.end()) * 2 - 1);",
			"",
			"    // 偶数長",
			"    vector<int> even(s.size());",
			"    for (int i = 0, l = 0, r = -1; i < s.size(); i++) {",
			"        int k = (i > r) ? 0 : min(even[l + r - i + 1], r - i + 1);",
			"        while (0 <= i - k - 1 && i + k < s.size() && s[i - k - 1] == s[i + k])",
			"            k++;",
			"        even[i] = k--;",
			"        ret = max(ret, k * 2);",
			"        if (i + k > r)",
			"            l = i - k - 1, r = i + k;",
			"    }",
			"    ret = max(ret, *max_element(even.begin(), even.end()) * 2);",
			"    return ret;",
			"}",
			"",
		],
		"description": ""
	},
	"range_query": {
		"prefix": "range_query",
		"body": [
			"void range_query(int n) {",
			"    segtree<ll, [](const ll a, const ll b) { return min(a, b); },",
			"            [] { return numeric_limits<ll>::max(); }>",
			"        RangeMinQuery(n);",
			"",
			"    segtree<ll, [](const ll a, const ll b) { return a + b; }, [] { return 0; }>",
			"        RangeSumQuery(n);",
			"",
			"    lazy_segtree<ll, [](const ll a, const ll b) { return min(a, b); },",
			"                 [] { return numeric_limits<ll>::max(); }, ll,",
			"                 [](const ll f, const ll x) {",
			"                     return f != numeric_limits<ll>::max() ? f : x;",
			"                 },",
			"                 [](const ll f, const ll g) {",
			"                     return f != numeric_limits<ll>::max() ? f : g;",
			"                 },",
			"                 [] { return numeric_limits<ll>::max(); }>",
			"        RangeMinUpdateQuery(n);",
			"",
			"    lazy_segtree<ll, [](const ll a, const ll b) { return min(a, b); },",
			"                 [] { return numeric_limits<ll>::max(); }, ll,",
			"                 [](const ll f, const ll x) { return f + x; },",
			"                 [](const ll f, const ll g) { return f + g; }, [] { return 0; }>",
			"        RangeMinAddQuery(n);",
			"",
			"    lazy_segtree<pair<ll, ll>,",
			"                 [](const pair<ll, ll> a, const pair<ll, ll> b) {",
			"                     return make_pair(a.first + b.first, a.second + b.second);",
			"                 },",
			"                 [] { return make_pair(0, 0); }, ll,",
			"                 [](const ll f, const pair<ll, ll> x) {",
			"                     return make_pair(f == numeric_limits<ll>::min()",
			"                                          ? x.first",
			"                                          : f * x.second,",
			"                                      x.second);",
			"                 },",
			"                 [](const ll f, const ll g) {",
			"                     return f == numeric_limits<ll>::min() ? g : f;",
			"                 },",
			"                 [] { return numeric_limits<ll>::min(); }>",
			"        RangeSumUpdateQuery(n);",
			"",
			"    lazy_segtree<pair<ll, ll>,",
			"                 [](const pair<ll, ll> a, const pair<ll, ll> b) {",
			"                     return make_pair(a.first + b.first, a.second + b.second);",
			"                 },",
			"                 [] { return make_pair(0, 0); }, ll,",
			"                 [](const ll f, const pair<ll, ll> x) {",
			"                     return make_pair(x.first + f * x.second, x.second);",
			"                 },",
			"                 [](const ll f, const ll g) { return f + g; }, [] { return 0; }>",
			"        RangeSumAddQuery(n);",
			"",
			"    struct DiffNode {",
			"        ll minVal, maxVal;",
			"        ll maxDiff;",
			"    };",
			"    segtree<DiffNode,",
			"            [](const DiffNode a, const DiffNode b) {",
			"                if (a.minVal == LLONG_MAX)",
			"                    return b;",
			"                if (b.minVal == LLONG_MAX)",
			"                    return a;",
			"                return DiffNode{",
			"                    min(a.minVal, b.minVal),",
			"                    max(a.maxVal, b.maxVal),",
			"                    max({a.maxDiff, b.maxDiff, b.maxVal - a.minVal}),",
			"                };",
			"            },",
			"            [] { return DiffNode{LLONG_MAX, LLONG_MIN, LLONG_MIN}; }>",
			"        RangeMaxDiffQuery(n);",
			"}",
			"",
		],
		"description": ""
	},
	"CycleDetection": {
		"prefix": "CycleDetection",
		"body": [
			"// Edge Class",
			"template <class T>",
			"struct Edge {",
			"    int from, to;",
			"    T val;",
			"    Edge() : from(-1), to(-1), val(-1) {}",
			"    Edge(int f, int t, T v = -1) : from(f), to(t), val(v) {}",
			"    friend ostream &operator<<(ostream &s, const Edge &E) {",
			"        return s << E.from << \"->\" << E.to;",
			"    }",
			"};",
			"",
			"template <class T>",
			"struct CycleDetection {",
			"    // input",
			"    vector<Edge<T>> G;",
			"",
			"    // intermediate results",
			"    vector<bool> seen, finished;",
			"    vector<int> history;",
			"",
			"    // constructor",
			"    CycleDetection() {}",
			"    CycleDetection(const vector<Edge<T>> &graph) { init(graph); }",
			"    void init(const vector<Edge<T>> &graph) {",
			"        G = graph;",
			"        seen.assign(G.size(), false);",
			"        finished.assign(G.size(), false);",
			"    }",
			"",
			"    // return the vertex where cycle is detected",
			"    int search(int v) {",
			"        do {",
			"            seen[v] = true;",
			"            history.push_back(v);",
			"            v = G[v].to;",
			"            if (finished[v]) {",
			"                v = -1;",
			"                break;",
			"            }",
			"        } while (!seen[v]);",
			"        pop_history();",
			"        return v;",
			"    }",
			"",
			"    // pop history",
			"    void pop_history() {",
			"        while (!history.empty()) {",
			"            int v = history.back();",
			"            finished[v] = true;",
			"            history.pop_back();",
			"        }",
			"    }",
			"",
			"    // reconstruct",
			"    vector<Edge<T>> reconstruct(int pos) {",
			"        // reconstruct the cycle",
			"        vector<Edge<T>> cycle;",
			"        int v = pos;",
			"        do {",
			"            cycle.push_back(G[v]);",
			"            v = G[v].to;",
			"        } while (v != pos);",
			"        return cycle;",
			"    }",
			"",
			"    // find cycle, v is the start vertex",
			"    vector<Edge<T>> detect_from_v(int v) {",
			"        int pos = search(v);",
			"        if (pos != -1)",
			"            return reconstruct(pos);",
			"        else",
			"            return vector<Edge<T>>();",
			"    }",
			"",
			"    // find all cycle",
			"    vector<vector<Edge<T>>> detect_all() {",
			"        vector<vector<Edge<T>>> res;",
			"        for (int v = 0; v < (int)G.size(); ++v) {",
			"            if (finished[v]) continue;",
			"            int pos = search(v);",
			"            if (pos == -1) continue;",
			"            const vector<Edge<T>> &cycle = reconstruct(pos);",
			"            if (!cycle.empty()) res.push_back(cycle);",
			"        }",
			"        return res;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"WaveletMatrix": {
		"prefix": "WaveletMatrix",
		"body": [
			"enum { NOTFOUND = 0xFFFFFFFFFFFFFFFFLLU };",
			"",
			"class SuccinctBitVector {",
			"  private:",
			"    const uint64_t size; // ビットベクトルのサイズ",
			"    static const uint64_t blockBitNum = 16;",
			"    static const uint64_t LEVEL_L = 512;",
			"    static const uint64_t LEVEL_S = 16;",
			"",
			"    std::vector<uint64_t> L; // 大ブロック",
			"    std::vector<uint16_t> S; // 小ブロック",
			"    std::vector<uint16_t> B; // ビットベクトル",
			"",
			"    uint64_t numOne = 0; // 1bitの数",
			"",
			"  public:",
			"    explicit SuccinctBitVector(const uint64_t n) : size(n) {",
			"        const uint64_t s =",
			"            (n + blockBitNum - 1) / blockBitNum + 1; // ceil(n, blockSize)",
			"        this->B.assign(s, 0);",
			"        this->L.assign(n / LEVEL_L + 1, 0);",
			"        this->S.assign(n / LEVEL_S + 1, 0);",
			"    }",
			"",
			"    // B[pos] = bit",
			"    void setBit(const uint64_t bit, const uint64_t pos) {",
			"        assert(bit == 0 or bit == 1);",
			"        assert(pos < this->size);",
			"",
			"        const uint64_t blockPos = pos / blockBitNum;",
			"        const uint64_t offset = pos % blockBitNum;",
			"        if (bit == 1) {",
			"            B.at(blockPos) |= (1LLU << offset);",
			"        } else {",
			"            B.at(blockPos) &= (~(1LLU << offset));",
			"        }",
			"    }",
			"",
			"    // B[pos]",
			"    uint64_t access(const uint64_t pos) {",
			"        assert(pos < this->size);",
			"        const uint64_t blockPos = pos / blockBitNum;",
			"        const uint64_t offset = pos % blockBitNum;",
			"        return ((B.at(blockPos) >> offset) & 1);",
			"    }",
			"",
			"    void build() {",
			"        uint64_t num = 0;",
			"        for (uint64_t i = 0; i <= size; i++) {",
			"            if (i % LEVEL_L == 0) {",
			"                L.at(i / LEVEL_L) = num;",
			"            }",
			"            if (i % LEVEL_S == 0) {",
			"                S.at(i / LEVEL_S) = num - L.at(i / LEVEL_L);",
			"            }",
			"            if (i != size and i % blockBitNum == 0) {",
			"                num += this->popCount(this->B.at(i / blockBitNum));",
			"            }",
			"        }",
			"        this->numOne = num;",
			"    }",
			"",
			"    // B[0, pos)のbitの数",
			"    uint64_t rank(const uint64_t bit, const uint64_t pos) {",
			"        assert(bit == 0 or bit == 1);",
			"        assert(pos <= this->size);",
			"",
			"        if (bit) {",
			"            return L[pos / LEVEL_L] + S[pos / LEVEL_S] +",
			"                   popCount(B[pos / blockBitNum] &",
			"                            ((1 << (pos % blockBitNum)) - 1));",
			"        } else {",
			"            return pos - rank(1, pos);",
			"        }",
			"    }",
			"",
			"    // rank番目のbitの位置 + 1(rankは1-origin)",
			"    uint64_t select(const uint64_t bit, const uint64_t rank) {",
			"        assert(bit == 0 or bit == 1);",
			"        assert(rank > 0);",
			"        if (bit == 0 and rank > this->size - this->numOne) {",
			"            return NOTFOUND;",
			"        }",
			"        if (bit == 1 and rank > this->numOne) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        // 大ブロックL内を検索",
			"        uint64_t large_idx = 0;",
			"        {",
			"            uint64_t left = 0;",
			"            uint64_t right = L.size();",
			"            while (right - left > 1) {",
			"                uint64_t mid = (left + right) / 2;",
			"                uint64_t r = L.at(mid);",
			"                r = (bit) ? r : mid * LEVEL_L - L.at(mid);",
			"",
			"                if (r < rank) {",
			"                    left = mid;",
			"                    large_idx = mid;",
			"                } else {",
			"                    right = mid;",
			"                }",
			"            }",
			"        }",
			"",
			"        // 小ブロックS内を検索",
			"        uint64_t small_idx = (large_idx * LEVEL_L) / LEVEL_S;",
			"        {",
			"            uint64_t left = (large_idx * LEVEL_L) / LEVEL_S;",
			"            uint64_t right = std::min(((large_idx + 1) * LEVEL_L) / LEVEL_S,",
			"                                      (uint64_t)S.size());",
			"            while (right - left > 1) {",
			"                uint64_t mid = (left + right) / 2;",
			"                uint64_t r = L.at(large_idx) + S.at(mid);",
			"                r = (bit) ? r : mid * LEVEL_S - r;",
			"",
			"                if (r < rank) {",
			"                    left = mid;",
			"                    small_idx = mid;",
			"                } else {",
			"                    right = mid;",
			"                }",
			"            }",
			"        }",
			"",
			"        // Bをブロック単位で順番に探索",
			"        uint64_t rank_pos = 0;",
			"        {",
			"            const uint64_t begin_block_idx =",
			"                (small_idx * LEVEL_S) / blockBitNum;",
			"            uint64_t total_bit = L.at(large_idx) + S.at(small_idx);",
			"            if (bit == 0) {",
			"                total_bit = small_idx * LEVEL_S - total_bit;",
			"            }",
			"            for (uint64_t i = 0;; ++i) {",
			"                uint64_t b = popCount(B.at(begin_block_idx + i));",
			"                if (bit == 0) {",
			"                    b = blockBitNum - b;",
			"                }",
			"                if (total_bit + b >= rank) {",
			"                    uint64_t block = (bit) ? B.at(begin_block_idx + i)",
			"                                           : ~B.at(begin_block_idx + i);",
			"                    rank_pos = (begin_block_idx + i) * blockBitNum +",
			"                               selectInBlock(block, rank - total_bit);",
			"                    break;",
			"                }",
			"                total_bit += b;",
			"            }",
			"        }",
			"",
			"        return rank_pos + 1;",
			"    }",
			"",
			"    uint64_t getNumOne() const { return numOne; }",
			"",
			"    void debug() {",
			"        std::cout << \"LEVEL_L(\" << L.size() << \")\" << std::endl;",
			"        for (uint64_t i = 0; i < L.size(); ++i) {",
			"            std::cout << L.at(i) << \", \";",
			"        }",
			"        std::cout << std::endl;",
			"        std::cout << \"LEVEL_S(\" << S.size() << \")\" << std::endl;",
			"        for (uint64_t i = 0; i < S.size(); ++i) {",
			"            std::cout << S.at(i) << \", \";",
			"        }",
			"        std::cout << std::endl;",
			"    }",
			"",
			"  private:",
			"    uint64_t popCount(uint64_t x) {",
			"        x = (x & 0x5555555555555555ULL) + ((x >> 1) & 0x5555555555555555ULL);",
			"        x = (x & 0x3333333333333333ULL) + ((x >> 2) & 0x3333333333333333ULL);",
			"        x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0fULL;",
			"        x = x + (x >> 8);",
			"        x = x + (x >> 16);",
			"        x = x + (x >> 32);",
			"        return x & 0x7FLLU;",
			"    }",
			"",
			"    uint64_t selectInBlock(uint64_t x, uint64_t rank) {",
			"        uint64_t x1 = x - ((x & 0xAAAAAAAAAAAAAAAALLU) >> 1);",
			"        uint64_t x2 =",
			"            (x1 & 0x3333333333333333LLU) + ((x1 >> 2) & 0x3333333333333333LLU);",
			"        uint64_t x3 = (x2 + (x2 >> 4)) & 0x0F0F0F0F0F0F0F0FLLU;",
			"",
			"        uint64_t pos = 0;",
			"        for (;; pos += 8) {",
			"            uint64_t rank_next = (x3 >> pos) & 0xFFLLU;",
			"            if (rank <= rank_next)",
			"                break;",
			"            rank -= rank_next;",
			"        }",
			"",
			"        uint64_t v2 = (x2 >> pos) & 0xFLLU;",
			"        if (rank > v2) {",
			"            rank -= v2;",
			"            pos += 4;",
			"        }",
			"",
			"        uint64_t v1 = (x1 >> pos) & 0x3LLU;",
			"        if (rank > v1) {",
			"            rank -= v1;",
			"            pos += 2;",
			"        }",
			"",
			"        uint64_t v0 = (x >> pos) & 0x1LLU;",
			"        if (v0 < rank) {",
			"            rank -= v0;",
			"            pos += 1;",
			"        }",
			"",
			"        return pos;",
			"    }",
			"};",
			"",
			"class WaveletMatrix {",
			"    // https://miti-7.hatenablog.com/entry/2018/04/28/152259#fnref:1",
			"  private:",
			"    std::vector<SuccinctBitVector> bit_arrays;",
			"    std::vector<uint64_t> begin_one; // 各bitに着目したときの1の開始位置",
			"    std::map<uint64_t, uint64_t>",
			"        begin_alphabet; // 最後のソートされた配列で各文字の開始位置",
			"    std::vector<std::vector<uint64_t>>",
			"        cumulative_sum; // 各bitに着目したときの累積和",
			"",
			"    uint64_t size;            // 与えられた配列のサイズ",
			"    uint64_t maximum_element; // 文字数",
			"    uint64_t bit_size;        // 文字を表すのに必要なbit数",
			"",
			"  public:",
			"    WaveletMatrix() {};",
			"    template <typename T> WaveletMatrix(const std::vector<T> &input) {",
			"        assert(input.size() > 0);",
			"        size = input.size();",
			"        std::vector<uint64_t> array(size);",
			"        for (uint64_t i = 0; i < size; i++) {",
			"            array[i] = (uint64_t)input[i];",
			"        }",
			"        maximum_element = *max_element(array.begin(), array.end()) + 1;",
			"        bit_size = get_num_of_bit(maximum_element);",
			"        if (bit_size == 0) {",
			"            bit_size = 1;",
			"        }",
			"",
			"        for (uint64_t i = 0; i < bit_size; ++i) {",
			"            SuccinctBitVector sv(size);",
			"            bit_arrays.push_back(sv);",
			"        }",
			"        this->begin_one.resize(bit_size);",
			"        this->cumulative_sum.resize(bit_size + 1,",
			"                                    std::vector<uint64_t>(size + 1, 0));",
			"",
			"        for (uint64_t j = 0; j < array.size(); ++j) {",
			"            this->cumulative_sum.at(0).at(j + 1) =",
			"                this->cumulative_sum.at(0).at(j) + array[j];",
			"        }",
			"",
			"        std::vector<uint64_t> v(array);",
			"        for (uint64_t i = 0; i < bit_size; ++i) {",
			"            std::vector<uint64_t> temp;",
			"            // 0をtempにいれてく",
			"            for (uint64_t j = 0; j < v.size(); ++j) {",
			"                uint64_t c = v.at(j);",
			"                uint64_t bit =",
			"                    (c >> (bit_size - i - 1)) & 1; // 　上からi番目のbit",
			"                if (bit == 0) {",
			"                    temp.push_back(c);",
			"                    bit_arrays.at(i).setBit(0, j);",
			"                }",
			"            }",
			"",
			"            this->begin_one.at(i) = temp.size();",
			"",
			"            // 1をtempにいれてく",
			"            for (uint64_t j = 0; j < v.size(); ++j) {",
			"                uint64_t c = v.at(j);",
			"                uint64_t bit =",
			"                    (c >> (bit_size - i - 1)) & 1; // 　上からi番目のbit",
			"                if (bit == 1) {",
			"                    temp.push_back(c);",
			"                    bit_arrays.at(i).setBit(1, j);",
			"                }",
			"            }",
			"",
			"            for (uint64_t j = 0; j < temp.size(); ++j) {",
			"                this->cumulative_sum.at(i + 1).at(j + 1) =",
			"                    this->cumulative_sum.at(i + 1).at(j) + temp.at(j);",
			"            }",
			"",
			"            bit_arrays.at(i).build();",
			"            v = temp;",
			"        }",
			"",
			"        // ソートされた配列内での各文字の位置を取得",
			"        for (int i = v.size() - 1; i >= 0; --i) {",
			"            this->begin_alphabet[v.at(i)] = i;",
			"        }",
			"    }",
			"",
			"    // v[pos]",
			"    uint64_t access(uint64_t pos) {",
			"        if (pos >= this->size) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        uint64_t c = 0;",
			"        for (uint64_t i = 0; i < bit_arrays.size(); ++i) {",
			"            uint64_t bit =",
			"                bit_arrays.at(i).access(pos); // もとの数値のi番目のbit",
			"            c = (c << 1) | bit;",
			"            pos = bit_arrays.at(i).rank(bit, pos);",
			"            if (bit) {",
			"                pos += this->begin_one.at(i);",
			"            }",
			"        }",
			"        return c;",
			"    }",
			"",
			"    // i番目のcの位置 + 1を返す。rankは1-origin",
			"    uint64_t select(uint64_t c, uint64_t rank) {",
			"        assert(rank > 0);",
			"        if (c >= maximum_element) {",
			"            return NOTFOUND;",
			"        }",
			"        if (this->begin_alphabet.find(c) == this->begin_alphabet.end()) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        uint64_t index = this->begin_alphabet.at(c) + rank;",
			"        for (uint64_t i = 0; i < bit_arrays.size(); ++i) {",
			"            uint64_t bit = ((c >> i) & 1); // 下からi番目のbit",
			"            if (bit == 1) {",
			"                index -= this->begin_one.at(bit_size - i - 1);",
			"            }",
			"            index = this->bit_arrays.at(bit_size - i - 1).select(bit, index);",
			"        }",
			"        return index;",
			"    }",
			"",
			"    // v[begin_pos, end_pos)で最大値のindexを返す",
			"    uint64_t maxRange(uint64_t begin_pos, uint64_t end_pos) {",
			"        return quantileRange(begin_pos, end_pos, end_pos - begin_pos - 1);",
			"    }",
			"",
			"    // v[begin_pos, end_pos)で最小値のindexを返す",
			"    uint64_t minRange(uint64_t begin_pos, uint64_t end_pos) {",
			"        return quantileRange(begin_pos, end_pos, 0);",
			"    }",
			"",
			"    // v[begin_pos, end_pos)でk番目に小さい数値のindexを返す(kは0-origin)",
			"    // つまり小さい順に並べてk番目の値",
			"    uint64_t quantileRange(uint64_t begin_pos, uint64_t end_pos, uint64_t k) {",
			"        if ((end_pos > size || begin_pos >= end_pos) ||",
			"            (k >= end_pos - begin_pos)) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        uint64_t val = 0;",
			"        for (uint64_t i = 0; i < bit_size; ++i) {",
			"            const uint64_t num_of_zero_begin =",
			"                bit_arrays.at(i).rank(0, begin_pos);",
			"            const uint64_t num_of_zero_end = bit_arrays.at(i).rank(0, end_pos);",
			"            const uint64_t num_of_zero =",
			"                num_of_zero_end -",
			"                num_of_zero_begin; // beginからendまでにある0の数",
			"            const uint64_t bit = (k < num_of_zero)",
			"                                     ? 0",
			"                                     : 1; // k番目の値の上からi番目のbitが0か1か",
			"",
			"            if (bit) {",
			"                k -= num_of_zero;",
			"                begin_pos =",
			"                    this->begin_one.at(i) + begin_pos - num_of_zero_begin;",
			"                end_pos = this->begin_one.at(i) + end_pos - num_of_zero_end;",
			"            } else {",
			"                begin_pos = num_of_zero_begin;",
			"                end_pos = num_of_zero_begin + num_of_zero;",
			"            }",
			"",
			"            val = ((val << 1) | bit);",
			"        }",
			"",
			"        uint64_t left = 0;",
			"        for (uint64_t i = 0; i < bit_size; ++i) {",
			"            const uint64_t bit =",
			"                (val >> (bit_size - i - 1)) & 1; // 上からi番目のbit",
			"            left = bit_arrays.at(i).rank(bit,",
			"                                         left); // cのi番目のbitと同じ数値の数",
			"            if (bit) {",
			"                left += this->begin_one.at(i);",
			"            }",
			"        }",
			"",
			"        const uint64_t rank = begin_pos + k - left + 1;",
			"        return select(val, rank) - 1;",
			"    }",
			"",
			"    // v[0, pos)のcの数",
			"    uint64_t rank(uint64_t c, uint64_t pos) {",
			"        assert(pos < size);",
			"        if (c >= maximum_element) {",
			"            return 0;",
			"        }",
			"        if (this->begin_alphabet.find(c) == this->begin_alphabet.end()) {",
			"            return 0;",
			"        }",
			"",
			"        for (uint64_t i = 0; i < bit_size; ++i) {",
			"            uint64_t bit = (c >> (bit_size - i - 1)) & 1; // 上からi番目のbit",
			"            pos =",
			"                bit_arrays.at(i).rank(bit, pos); // cのi番目のbitと同じ数値の数",
			"            if (bit) {",
			"                pos += this->begin_one.at(i);",
			"            }",
			"        }",
			"",
			"        uint64_t begin_pos = this->begin_alphabet.at(c);",
			"        return pos - begin_pos;",
			"    }",
			"",
			"    // v[begin_pos, end_pos)で[min, max)に入る値の個数",
			"    uint64_t rangeFreq(uint64_t begin_pos, uint64_t end_pos, uint64_t min_c,",
			"                       uint64_t max_c) {",
			"        if ((end_pos > size || begin_pos >= end_pos) || (min_c >= max_c) ||",
			"            min_c >= maximum_element) {",
			"            return 0;",
			"        }",
			"",
			"        const auto maxi_t = rankAll(max_c, begin_pos, end_pos);",
			"        const auto mini_t = rankAll(min_c, begin_pos, end_pos);",
			"        return std::get<1>(maxi_t) - std::get<1>(mini_t);",
			"    }",
			"",
			"    // v[0, pos)でcより小さい文字の数",
			"    uint64_t rankLessThan(uint64_t c, uint64_t begin, uint64_t end) {",
			"        auto t = rankAll(c, begin, end);",
			"        return std::get<1>(t);",
			"    }",
			"",
			"    // v[0, pos)でcより大きい文字の数",
			"    uint64_t rankMoreThan(uint64_t c, uint64_t begin, uint64_t end) {",
			"        auto t = rankAll(c, begin, end);",
			"        return std::get<2>(t);",
			"    }",
			"",
			"    // v[begin,",
			"    // end)で(cと同じ値の数、cより小さい値の数、cより大きい値の数)を求める",
			"    std::tuple<uint64_t, uint64_t, uint64_t>",
			"    rankAll(const uint64_t c, uint64_t begin, uint64_t end) {",
			"        assert(end <= size);",
			"        const uint64_t num = end - begin;",
			"",
			"        if (begin >= end) {",
			"            return std::make_tuple(0, 0, 0);",
			"        }",
			"        if (c >= maximum_element || end == 0) {",
			"            return std::make_tuple(0, num, 0);",
			"        }",
			"",
			"        uint64_t rank_less_than = 0, rank_more_than = 0;",
			"        for (size_t i = 0; i < bit_size && begin < end; ++i) {",
			"            const uint64_t bit = (c >> (bit_size - i - 1)) & 1;",
			"",
			"            const uint64_t rank0_begin = this->bit_arrays.at(i).rank(0, begin);",
			"            const uint64_t rank0_end = this->bit_arrays.at(i).rank(0, end);",
			"            const uint64_t rank1_begin = begin - rank0_begin;",
			"            const uint64_t rank1_end = end - rank0_end;",
			"",
			"            if (bit) {",
			"                rank_less_than +=",
			"                    (rank0_end -",
			"                     rank0_begin); // i番目のbitが0のものは除外される",
			"                begin = this->begin_one.at(i) + rank1_begin;",
			"                end = this->begin_one.at(i) + rank1_end;",
			"            } else {",
			"                rank_more_than +=",
			"                    (rank1_end -",
			"                     rank1_begin); // i番目のbitが1のものは除外される",
			"                begin = rank0_begin;",
			"                end = rank0_end;",
			"            }",
			"        }",
			"",
			"        const uint64_t rank = num - rank_less_than - rank_more_than;",
			"        return std::make_tuple(rank, rank_less_than, rank_more_than);",
			"    }",
			"",
			"    // T[s, e)で出現回数が多い順にk個の(値，頻度)を返す",
			"    // 頻度が同じ場合は値が小さいものが優先される",
			"    std::vector<std::pair<uint64_t, uint64_t>> topk(uint64_t s, uint64_t e,",
			"                                                    uint64_t k) {",
			"        assert(s < e);",
			"        std::vector<std::pair<uint64_t, uint64_t>> result;",
			"",
			"        // (頻度，深さ，値)の順でソート",
			"        auto c = [](const std::tuple<uint64_t, uint64_t, uint64_t, uint64_t,",
			"                                     uint64_t> &l,",
			"                    const std::tuple<uint64_t, uint64_t, uint64_t, uint64_t,",
			"                                     uint64_t> &r) {",
			"            // width",
			"            if (std::get<0>(l) != std::get<0>(r)) {",
			"                return std::get<0>(l) < std::get<0>(r);",
			"            }",
			"            // depth",
			"            if (std::get<3>(l) != std::get<3>(r)) {",
			"                return std::get<3>(l) > std::get<3>(r);",
			"            }",
			"            // value",
			"            if (std::get<4>(l) != std::get<4>(r)) {",
			"                return std::get<4>(l) > std::get<4>(r);",
			"            }",
			"            return true;",
			"        };",
			"",
			"        std::priority_queue<",
			"            std::tuple<uint64_t, uint64_t, uint64_t, uint64_t, uint64_t>,",
			"            std::vector<",
			"                std::tuple<uint64_t, uint64_t, uint64_t, uint64_t, uint64_t>>,",
			"            decltype(c)>",
			"            que(c); // width, left, right, depth, value",
			"        que.push(std::make_tuple(e - s, s, e, 0, 0));",
			"",
			"        while (not que.empty()) {",
			"            auto element = que.top();",
			"            que.pop();",
			"            uint64_t width, left, right, depth, value;",
			"            std::tie(width, left, right, depth, value) = element;",
			"",
			"            if (depth >= this->bit_size) {",
			"                result.emplace_back(std::make_pair(value, right - left));",
			"                if (result.size() >= k) {",
			"                    break;",
			"                }",
			"                continue;",
			"            }",
			"",
			"            // 0",
			"            const uint64_t left0 = this->bit_arrays.at(depth).rank(0, left);",
			"            const uint64_t right0 = this->bit_arrays.at(depth).rank(0, right);",
			"            if (left0 < right0) {",
			"                que.push(std::make_tuple(right0 - left0, left0, right0,",
			"                                         depth + 1, value));",
			"            }",
			"",
			"            // 1",
			"            const uint64_t left1 = this->begin_one.at(depth) +",
			"                                   this->bit_arrays.at(depth).rank(1, left);",
			"            const uint64_t right1 = this->begin_one.at(depth) +",
			"                                    this->bit_arrays.at(depth).rank(1, right);",
			"            if (left1 < right1) {",
			"                que.push(",
			"                    std::make_tuple(right1 - left1, left1, right1, depth + 1,",
			"                                    value | (1 << (bit_size - depth - 1))));",
			"            }",
			"        }",
			"",
			"        return result;",
			"    };",
			"",
			"    // T[begin_pos, end_pos)でx <= c < yを満たすcの和を返す",
			"    uint64_t rangeSum(const uint64_t begin, const uint64_t end,",
			"                      const uint64_t x, const uint64_t y) {",
			"        return rangeSum(begin, end, 0, 0, x, y);",
			"    }",
			"",
			"    // T[begin_pos, end_pos)でx <= c < yを満たす最大のcを返す",
			"    uint64_t prevValue(const uint64_t begin_pos, const uint64_t end_pos,",
			"                       const uint64_t x, uint64_t y) {",
			"        assert(end_pos <= size);",
			"        const uint64_t num = end_pos - begin_pos;",
			"",
			"        if (x >= y or y == 0) {",
			"            return NOTFOUND;",
			"        }",
			"        if (y > maximum_element) {",
			"            y = maximum_element;",
			"        }",
			"",
			"        if (begin_pos >= end_pos) {",
			"            return NOTFOUND;",
			"        }",
			"        if (x >= maximum_element || end_pos == 0) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        y--; // x <= c <= yにする",
			"",
			"        std::stack<std::tuple<uint64_t, uint64_t, uint64_t, uint64_t, bool>>",
			"            s; // (begin, end, depth, c, tight)",
			"        s.emplace(std::make_tuple(begin_pos, end_pos, 0, 0, true));",
			"",
			"        while (not s.empty()) {",
			"            uint64_t b, e, depth, c;",
			"            bool tight;",
			"            std::tie(b, e, depth, c, tight) = s.top();",
			"            s.pop();",
			"",
			"            if (depth == bit_size) {",
			"                if (c >= x) {",
			"                    return c;",
			"                }",
			"                continue;",
			"            }",
			"",
			"            const uint64_t bit = (y >> (bit_size - depth - 1)) & 1;",
			"",
			"            const uint64_t rank0_begin = this->bit_arrays.at(depth).rank(0, b);",
			"            const uint64_t rank0_end = this->bit_arrays.at(depth).rank(0, e);",
			"            const uint64_t rank1_begin = b - rank0_begin;",
			"            const uint64_t rank1_end = e - rank0_end;",
			"",
			"            // d番目のbitが0のものを使う",
			"            const uint64_t b0 = rank0_begin;",
			"            const uint64_t e0 = rank0_end;",
			"            if (b0 != e0) { // 範囲がつぶれてない",
			"                const uint64_t c0 = ((c << 1) | 0);",
			"                s.emplace(",
			"                    std::make_tuple(b0, e0, depth + 1, c0, tight and bit == 0));",
			"            }",
			"",
			"            // d番目のbitが1のものを使う",
			"            const uint64_t b1 = this->begin_one.at(depth) + rank1_begin;",
			"            const uint64_t e1 = this->begin_one.at(depth) + rank1_end;",
			"            if (b1 != e1) {",
			"                if (not tight or bit == 1) {",
			"                    const auto c1 = ((c << 1) | 1);",
			"                    s.emplace(std::make_tuple(b1, e1, depth + 1, c1, tight));",
			"                }",
			"            }",
			"        }",
			"",
			"        return NOTFOUND;",
			"    }",
			"",
			"    // T[begin_pos, end_pos)でx <= c < yを満たす最小のcを返す",
			"    uint64_t nextValue(const uint64_t begin_pos, const uint64_t end_pos,",
			"                       const uint64_t x, const uint64_t y) {",
			"        assert(end_pos <= size);",
			"        const uint64_t num = end_pos - begin_pos;",
			"",
			"        if (x >= y or y == 0) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        if (begin_pos >= end_pos) {",
			"            return NOTFOUND;",
			"        }",
			"        if (x >= maximum_element || end_pos == 0) {",
			"            return NOTFOUND;",
			"        }",
			"",
			"        std::stack<std::tuple<uint64_t, uint64_t, uint64_t, uint64_t, bool>>",
			"            s; // (begin, end, depth, c, tight)",
			"        s.emplace(std::make_tuple(begin_pos, end_pos, 0, 0, true));",
			"",
			"        while (not s.empty()) {",
			"            uint64_t b, e, depth, c;",
			"            bool tight;",
			"            std::tie(b, e, depth, c, tight) = s.top();",
			"            s.pop();",
			"",
			"            if (depth == bit_size) {",
			"                if (c < y) {",
			"                    return c;",
			"                }",
			"                continue;",
			"            }",
			"",
			"            const uint64_t bit = (x >> (bit_size - depth - 1)) & 1;",
			"",
			"            const uint64_t rank0_begin = this->bit_arrays.at(depth).rank(0, b);",
			"            const uint64_t rank0_end = this->bit_arrays.at(depth).rank(0, e);",
			"            const uint64_t rank1_begin = b - rank0_begin;",
			"            const uint64_t rank1_end = e - rank0_end;",
			"",
			"            // d番目のbitが1のものを使う",
			"            const uint64_t b1 = this->begin_one.at(depth) + rank1_begin;",
			"            const uint64_t e1 = this->begin_one.at(depth) + rank1_end;",
			"            if (b1 != e1) {",
			"                const auto c1 = ((c << 1) | 1);",
			"                s.emplace(",
			"                    std::make_tuple(b1, e1, depth + 1, c1, tight and bit == 1));",
			"            }",
			"",
			"            // d番目のbitが0のものを使う",
			"            const uint64_t b0 = rank0_begin;",
			"            const uint64_t e0 = rank0_end;",
			"            if (b0 != e0) {",
			"                if (not tight or bit == 0) {",
			"                    const uint64_t c0 = ((c << 1) | 0);",
			"                    s.emplace(std::make_tuple(b0, e0, depth + 1, c0, tight));",
			"                }",
			"            }",
			"        }",
			"",
			"        return NOTFOUND;",
			"    }",
			"",
			"    // T[s1, e1)とT[s2, e2)に共通して出現する要素を求める",
			"    std::vector<std::tuple<uint64_t, uint64_t, uint64_t>>",
			"    intersect(uint64_t _s1, uint64_t _e1, uint64_t _s2, uint64_t _e2) {",
			"        assert(_s1 < _e1);",
			"        assert(_s2 < _e2);",
			"",
			"        std::vector<std::tuple<uint64_t, uint64_t, uint64_t>> intersection;",
			"",
			"        std::queue<std::tuple<uint64_t, uint64_t, uint64_t, uint64_t, uint64_t,",
			"                              uint64_t>>",
			"            que; // s1, e1, s2, e2, depth, value",
			"        que.push(std::make_tuple(_s1, _e1, _s2, _e2, 0, 0));",
			"        while (not que.empty()) {",
			"            auto e = que.front();",
			"            que.pop();",
			"            uint64_t s1, e1, s2, e2, depth, value;",
			"            std::tie(s1, e1, s2, e2, depth, value) = e;",
			"",
			"            if (depth >= this->bit_size) {",
			"                intersection.emplace_back(",
			"                    std::make_tuple(value, e1 - s1, e2 - s2));",
			"                continue;",
			"            }",
			"",
			"            // 0",
			"            uint64_t s1_0 = this->bit_arrays.at(depth).rank(0, s1);",
			"            uint64_t e1_0 = this->bit_arrays.at(depth).rank(0, e1);",
			"            uint64_t s2_0 = this->bit_arrays.at(depth).rank(0, s2);",
			"            uint64_t e2_0 = this->bit_arrays.at(depth).rank(0, e2);",
			"",
			"            if (s1_0 != e1_0 and s2_0 != e2_0) {",
			"                que.push(",
			"                    std::make_tuple(s1_0, e1_0, s2_0, e2_0, depth + 1, value));",
			"            }",
			"",
			"            // 1",
			"            uint64_t s1_1 = this->begin_one.at(depth) +",
			"                            this->bit_arrays.at(depth).rank(1, s1);",
			"            uint64_t e1_1 = this->begin_one.at(depth) +",
			"                            this->bit_arrays.at(depth).rank(1, e1);",
			"            uint64_t s2_1 = this->begin_one.at(depth) +",
			"                            this->bit_arrays.at(depth).rank(1, s2);",
			"            uint64_t e2_1 = this->begin_one.at(depth) +",
			"                            this->bit_arrays.at(depth).rank(1, e2);",
			"",
			"            if (s1_1 != e1_1 and s2_1 != e2_1) {",
			"                que.push(",
			"                    std::make_tuple(s1_1, e1_1, s2_1, e2_1, depth + 1,",
			"                                    value | (1 << (bit_size - depth - 1))));",
			"            }",
			"        }",
			"",
			"        return intersection;",
			"    };",
			"",
			"  private:",
			"    uint64_t get_num_of_bit(uint64_t x) {",
			"        if (x == 0)",
			"            return 0;",
			"        x--;",
			"        uint64_t bit_num = 0;",
			"        while (x >> bit_num) {",
			"            ++bit_num;",
			"        }",
			"        return bit_num;",
			"    }",
			"",
			"    uint64_t rangeSum(const uint64_t begin, const uint64_t end,",
			"                      const uint64_t depth, const uint64_t c, const uint64_t x,",
			"                      const uint64_t y) {",
			"        if (begin == end) {",
			"            return 0;",
			"        }",
			"",
			"        if (depth == bit_size) {",
			"            if (x <= c and c < y) {",
			"                return c * (end - begin); // 値 * 頻度",
			"            }",
			"            return 0;",
			"        }",
			"",
			"        const uint64_t next_c = ((uint64_t)1 << (bit_size - depth - 1)) |",
			"                                c; // 上からdepth番目のbitを立てる",
			"        const uint64_t all_one_c =",
			"            (((uint64_t)1 << (bit_size - depth - 1)) - 1) |",
			"            next_c; // depth以降のbitをたてる(これ以降全部1を選んだときの値)",
			"        if (all_one_c < x or y <= c) {",
			"            return 0;",
			"        }",
			"",
			"        // [begin, pos)のすべての要素は[x, y)",
			"        if (x <= c and all_one_c < y) {",
			"            return this->cumulative_sum.at(depth).at(end) -",
			"                   this->cumulative_sum.at(depth).at(begin);",
			"        }",
			"",
			"        const uint64_t rank0_begin = this->bit_arrays.at(depth).rank(0, begin);",
			"        const uint64_t rank0_end = this->bit_arrays.at(depth).rank(0, end);",
			"        const uint64_t rank1_begin = begin - rank0_begin;",
			"        const uint64_t rank1_end = end - rank0_end;",
			"",
			"        return rangeSum(rank0_begin, rank0_end, depth + 1, c, x, y) +",
			"               rangeSum(this->begin_one.at(depth) + rank1_begin,",
			"                        this->begin_one[depth] + rank1_end, depth + 1, next_c,",
			"                        x, y);",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"PointAddRectangleSum": {
		"prefix": "PointAddRectangleSum",
		"body": [
			"struct PointAddRectangleSum {",
			"",
			"    template <typename T, T (*id)(), T (*op)(T, T), T (*inv)(T)>",
			"    struct fenwick_tree_abstract {",
			"        int N, W;",
			"        std::vector<T> V;",
			"",
			"        fenwick_tree_abstract() {}",
			"        fenwick_tree_abstract(int _N) : N(_N), W(bit_ceil(N)), V(N + 1, id()) {}",
			"        fenwick_tree_abstract(const std::vector<T> &v)",
			"            : N(v.size()), W(bit_ceil(N)), V(1, id()) {",
			"            V.insert(V.begin() + 1, v.begin(), v.end());",
			"            for (int i = 1; i <= N; i++) {",
			"                int nxt = i + (i & (-i));",
			"                if (nxt <= N)",
			"                    V[nxt] += V[i];",
			"            }",
			"        }",
			"",
			"        unsigned int bit_ceil(unsigned int n) {",
			"            unsigned int x = 1;",
			"            while (x < (unsigned int)(n))",
			"                x *= 2;",
			"            return x;",
			"        }",
			"",
			"        void apply(int k, T x) {",
			"            for (int i = k + 1; i <= N; i += (i & (-i))) {",
			"                V[i] = op(V[i], x);",
			"            }",
			"        }",
			"",
			"        T prod(int r) {",
			"            T res = id();",
			"            for (int k = r; k > 0; k -= (k & (-k))) {",
			"                res = op(V[k], res);",
			"            }",
			"            return res;",
			"        }",
			"",
			"        T prod(int l, int r) { return op(inv(prod(l)), prod(r)); }",
			"",
			"        template <bool (*f)(T)> int max_right() {",
			"            assert(f(id()));",
			"            int r = 0, w = W;",
			"            T s = 0, tmp;",
			"            while (w) {",
			"                if (r + w <= N && f((tmp = op(s, V[r + w])))) {",
			"                    s = tmp;",
			"                    r += w;",
			"                }",
			"                w >>= 1;",
			"            }",
			"            return r;",
			"        }",
			"    };",
			"",
			"    template <typename T> struct _fenwick_add_sum {",
			"        static long long id() { return 0; }",
			"        static long long inv(long long a) { return -a; }",
			"        static long long merge(long long a, long long b) { return a + b; }",
			"    };",
			"",
			"    template <typename T>",
			"    using fenwick_tree = fenwick_tree_abstract<T, _fenwick_add_sum<T>::id,",
			"                                               _fenwick_add_sum<T>::merge,",
			"                                               _fenwick_add_sum<T>::inv>;",
			"",
			"    struct query_type {",
			"        int id;",
			"        long long lx, rx, ly, ry;",
			"        long long z;",
			"        query_type(int a, long long b, long long c, long long d, long long e,",
			"                   long long f)",
			"            : id(a), lx(b), rx(c), ly(d), ry(e), z(f) {}",
			"    };",
			"",
			"    struct event_type {",
			"        long long x;",
			"        int q, id;",
			"        int lyc, ryc;",
			"        long long z;",
			"        event_type(long long a, int b, int c, int d, int e, long long f)",
			"            : x(a), q(b), id(c), lyc(d), ryc(e), z(f) {}",
			"    };",
			"",
			"    std::vector<query_type> q;",
			"    std::vector<int> qcount{0};",
			"    int qs = 0;",
			"",
			"    void solve(int l, int r, std::vector<long long> &ans) {",
			"        static constexpr int DO_NAIVE = 100;",
			"        if (r - l < 2)",
			"            return;",
			"        if (r - l <= DO_NAIVE) {",
			"            for (int i = l; i < r; i++) {",
			"                if (q[i].id == -1)",
			"                    continue;",
			"                for (int j = l; j < i; j++) {",
			"                    if (q[j].id == -1 && q[i].lx <= q[j].lx &&",
			"                        q[j].lx < q[i].rx && q[i].ly <= q[j].ly &&",
			"                        q[j].ly < q[i].ry) {",
			"                        ans[q[i].id] += q[j].z;",
			"                    }",
			"                }",
			"            }",
			"            return;",
			"        }",
			"",
			"        int mid = (l + r) >> 1;",
			"        solve(l, mid, ans);",
			"        solve(mid, r, ans);",
			"        int left_update = (mid - l) - (qcount[mid] - qcount[l]);",
			"        int right_query = qcount[r] - qcount[mid];",
			"        if (left_update == 0 || right_query == 0)",
			"            return;",
			"",
			"        std::vector<long long> y;",
			"        for (int i = l; i < mid; i++) {",
			"            if (q[i].id == -1) {",
			"                y.push_back(q[i].ly);",
			"            }",
			"        }",
			"        std::sort(y.begin(), y.end());",
			"        y.erase(std::unique(y.begin(), y.end()), y.end());",
			"",
			"        fenwick_tree<long long> ft(y.size());",
			"        std::vector<event_type> e;",
			"        for (int i = l; i < mid; i++) {",
			"            if (q[i].id == -1) {",
			"                int y_idx =",
			"                    std::lower_bound(y.begin(), y.end(), q[i].ly) - y.begin();",
			"                e.push_back(event_type(q[i].lx, 2, -1, y_idx, 0, q[i].z));",
			"            }",
			"        }",
			"",
			"        for (int i = mid; i < r; i++) {",
			"            if (q[i].id != -1) {",
			"                int ly_idx =",
			"                    std::lower_bound(y.begin(), y.end(), q[i].ly) - y.begin();",
			"                int ry_idx =",
			"                    std::lower_bound(y.begin(), y.end(), q[i].ry) - y.begin();",
			"                e.push_back(event_type(q[i].lx, 0, q[i].id, ly_idx, ry_idx, 0));",
			"                e.push_back(event_type(q[i].rx, 1, q[i].id, ly_idx, ry_idx, 0));",
			"            }",
			"        }",
			"",
			"        std::sort(e.begin(), e.end(), [](event_type &a, event_type &b) {",
			"            if (a.x != b.x)",
			"                return a.x < b.x;",
			"            return a.q < b.q;",
			"        });",
			"",
			"        for (event_type &ei : e) {",
			"            if (ei.q == 0) {",
			"                ans[ei.id] -= ft.prod(ei.lyc, ei.ryc);",
			"            } else if (ei.q == 1) {",
			"                ans[ei.id] += ft.prod(ei.lyc, ei.ryc);",
			"            } else {",
			"                ft.apply(ei.lyc, ei.z);",
			"            }",
			"        }",
			"    }",
			"",
			"    /**",
			"     * 点 (x, y) に z を加算する",
			"     */",
			"    void add(long long x, long long y, long long z) {",
			"        q.push_back(query_type(-1, x, 0, y, 0, z));",
			"        qcount.push_back(0);",
			"    }",
			"",
			"    /**",
			"     * [lx, rx) * [ly, ry) の範囲内にある点の値の合計を求める",
			"     */",
			"    void query(long long lx, long long rx, long long ly, long long ry) {",
			"        q.push_back(query_type(qs++, lx, rx, ly, ry, 0));",
			"        qcount.push_back(1);",
			"    }",
			"",
			"    /**",
			"     * クエリを解く",
			"     */",
			"    vector<long long> solve() {",
			"        vector<long long> res(qs, 0);",
			"        for (int i = 1; i < (int)qcount.size(); i++) {",
			"            qcount[i] += qcount[i - 1];",
			"        }",
			"        solve(0, q.size(), res);",
			"        return res;",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
	"RangeCount": {
		"prefix": "RangeCount",
		"body": [
			"struct RangeCount {",
			"    PointAddRectangleSum rect;",
			"    RangeCount() {}",
			"",
			"    /**",
			"     * [l, r] の区間を cnt 個追加する",
			"     */",
			"    void add(long long l, long long r, long long cnt = 1) {",
			"        rect.add(l, r, cnt);",
			"    }",
			"",
			"    /**",
			"     * [l, r] の区間内にいくつの区間が含まれるかのクエリを追加",
			"     */",
			"    void query(long long l, long long r) { rect.query(l, r + 1, l, r + 1); }",
			"",
			"    /**",
			"     * クエリを解く",
			"     */",
			"    vector<long long> solve() { return rect.solve(); }",
			"};",
			"",
		],
		"description": ""
	},
	"RerootingDP": {
		"prefix": "RerootingDP",
		"body": [
			"template <class E, class V, E (*merge)(E, E), E (*e)(), E (*put_edge)(V, int),",
			"          V (*put_vertex)(E, int)>",
			"struct RerootingDP {",
			"    // https://trap.jp/post/1702/",
			"    struct edge {",
			"        int to, idx, xdi;",
			"    };",
			"    RerootingDP(int n_ = 0) : n(n_), inner_edge_id(0) {",
			"        es.resize(2 * n - 2);",
			"        start.resize(2 * n - 2);",
			"        if (n == 1) es_build();",
			"    }",
			"    void add_edge(int u, int v, int idx, int xdi) {",
			"        start[inner_edge_id] = u;",
			"        es[inner_edge_id] = {v, idx, xdi};",
			"        inner_edge_id++;",
			"        start[inner_edge_id] = v;",
			"        es[inner_edge_id] = {u, xdi, idx};",
			"        inner_edge_id++;",
			"        if (inner_edge_id == 2 * n - 2) {",
			"            es_build();",
			"        }",
			"    }",
			"    vector<V> build(int root_ = 0) {",
			"        root = root_;",
			"        vector<V> subdp(n);",
			"        subdp[0] = put_vertex(e(), 0);",
			"        outs.resize(n);",
			"        vector<int> geta(n + 1, 0);",
			"        for (int i = 0; i < n; i++) geta[i + 1] = start[i + 1] - start[i] - 1;",
			"        geta[root + 1]++;",
			"        for (int i = 0; i < n; i++) geta[i + 1] += geta[i];",
			"        auto dfs = [&](auto sfs, int v, int f) -> void {",
			"            E val = e();",
			"            for (int i = start[v]; i < start[v + 1]; i++) {",
			"                if (es[i].to == f) {",
			"                    swap(es[start[v + 1] - 1], es[i]);",
			"                }",
			"                if (es[i].to == f) continue;",
			"                sfs(sfs, es[i].to, v);",
			"                E nval = put_edge(subdp[es[i].to], es[i].idx);",
			"                outs[geta[v]++] = nval;",
			"                val = merge(val, nval);",
			"            }",
			"            subdp[v] = put_vertex(val, v);",
			"        };",
			"        dfs(dfs, root, -1);",
			"        return subdp;",
			"    }",
			"    vector<V> reroot() {",
			"        vector<E> reverse_edge(n);",
			"        reverse_edge[root] = e();",
			"        vector<V> answers(n);",
			"        auto dfs = [&](auto sfs, int v) -> void {",
			"            int le = outs_start(v);",
			"            int ri = outs_start(v + 1);",
			"            int siz = ri - le;",
			"            vector<E> rui(siz + 1);",
			"            rui[siz] = e();",
			"            for (int i = siz - 1; i >= 0; i--) {",
			"                rui[i] = merge(outs[le + i], rui[i + 1]);",
			"            }",
			"            answers[v] = put_vertex(merge(rui[0], reverse_edge[v]), v);",
			"            E lui = e();",
			"            for (int i = 0; i < siz; i++) {",
			"                V rdp = put_vertex(",
			"                    merge(merge(lui, rui[i + 1]), reverse_edge[v]), v);",
			"                reverse_edge[es[start[v] + i].to] =",
			"                    put_edge(rdp, es[start[v] + i].xdi);",
			"                lui = merge(lui, outs[le + i]);",
			"                sfs(sfs, es[start[v] + i].to);",
			"            }",
			"        };",
			"        dfs(dfs, root);",
			"        return answers;",
			"    }",
			"",
			"   private:",
			"    int n, root, inner_edge_id;",
			"    vector<E> outs;",
			"    vector<edge> es;",
			"    vector<int> start;",
			"    int outs_start(int v) {",
			"        int res = start[v] - v;",
			"        if (root < v) res++;",
			"        return res;",
			"    }",
			"    void es_build() {",
			"        vector<edge> nes(2 * n - 2);",
			"        vector<int> nstart(n + 2, 0);",
			"        for (int i = 0; i < 2 * n - 2; i++) nstart[start[i] + 2]++;",
			"        for (int i = 0; i < n; i++) nstart[i + 1] += nstart[i];",
			"        for (int i = 0; i < 2 * n - 2; i++) nes[nstart[start[i] + 1]++] = es[i];",
			"        swap(es, nes);",
			"        swap(start, nstart);",
			"    }",
			"};",
			"",
			"mint merge(mint a, mint b) { return a * b; }",
			"mint e() { return mint(1); }",
			"mint put_edge(mint v, int i) { return v + 1; }",
			"mint put_vertex(mint e, int v) { return e; }",
		],
		"description": ""
	},
	"DivideAndConquer": {
		"prefix": "DivideAndConquer",
		"body": [
			"struct DivideAndConquer {",
			"    vector<int> ans;",
			"    DivideAndConquer(int n) : ans(n) { recursive(0, n); }",
			"    void snapshot() {",
			"        // ここにスナップショットを取る処理を書く",
			"    }",
			"    void rollback() {",
			"        // ここにロールバックを行う処理を書く",
			"    }",
			"    void add(int i) {",
			"        // ここにi番目の要素を追加する処理を書く",
			"    }",
			"    void recursive(int l, int r) {",
			"        if (r - l == 1) {",
			"            // ここに終了条件の処理を書く",
			"            return;",
			"        }",
			"        int c = (l + r) / 2;",
			"        snapshot();",
			"        for (int i = c; i < r; i++) add(i);",
			"        recursive(l, c);",
			"        rollback();",
			"        snapshot();",
			"        for (int i = l; i < c; i++) add(i);",
			"        recursive(c, r);",
			"        rollback();",
			"    }",
			"};",
			"",
		],
		"description": ""
	},
}